version "4.14.2"
// Version: 1.0beta30
// Date: 2025-09-05 14:14:00 EDT
// Patch Notes:
// - **Beta 29 – Code cleanup & deprecation removal**
//   • Removed the nonfunctional Nightmare Protocol boon and all related code (enum, names,
//     descriptions, colour/font mappings and application).  Acceleration stacks remain but
//     are now only incremented by UAC Combat Drills. — Effect: Improved — Conf: 94.0000%
//   • Deleted the legacy ApplyBoon_Old function and unused patch‑notes scaffolding.  All
//     callers now refer to the modern ApplyBoon implementation. — Effect: Improved — Conf: 93.0000%
//   • Pruned some internal comments and historical notes to reduce file size. — Effect: Improved — Conf: 92.5000%
//   • Added this release header; previous patch notes retained below for reference.
//   • Doc cross‑check: verified modifications against the GZDoom 4.14.2 reference (StatusBarEventHandler.RenderOverlay,
//     A_Log, A_PrintBold, CVar usage) — Effect: Neutral — Conf: 96.0000%
// - **Beta 28 – Boon toast de‑duplication**
//   • **Comprehensive audit of toast messages** – Removed redundant magnitudes and
//     durations from the extra strings passed to `PrintBoonConsole()`.  Timed
//     boons such as UAC XP Surge, Quad Damage and Soul Siphon no longer repeat
//     their effect names or durations in parentheses.  Permanent bonuses like
//     Berserking Firepower, Raise Max Health/Armor and Raise Max Health Minor
//     now omit the "+X" detail in the extra string since the description
//     already conveys the increase.  Adrenal Surge’s extra text was reduced
//     to “Shield,” and UAC Combat Drills and Overcharger removed their
//     duplicate +15 % notices.  Marine Grit, Executioner, Bulwark Shards and
//     other boons retain numerical extras where they add new information.
//   • **Soul Siphon extra simplified** – The extra string for Soul Siphon now
//     only lists the heal amount per kill (e.g., “+1 HP/kill”).  The
//     duration is left to the description to avoid repetition.  Debug logs
//     continue to show precise timing.
//   • **Raise Max HP/Armor extras removed** – Picking up a raise boon no
//     longer spams “+25 MaxHP”/“+25 MaxArmor” in the toast; the short
//     descriptions (“+25 max HP,” “+25 max armor,” “+5 max HP”) suffice.
//   • **Berserking Firepower extra removed** – The toast for this boon no
//     longer repeats “+15 % global dmg”; the description already states
//     it.  Max‑health damage retains a +25 % extra since the base description
//     omits the exact percentage.
// - **Beta 27 – HUD and boon messaging cleanup**
//   • **Buff overlay repositioned again** – Increased the bottom margin of the
//     timed‑buff list from 90 px to 120 px so it sits clearly above the HUD
//     across all resolutions.  This addresses player feedback that the timers
//     were still too low and hard to read in beta 26.
//   • **Simplified boon toasts** – Removed the "Boon Gained" prefix and
//     reformatted acquisition messages to display `<Name>:` on one line
//     followed by the description on the next.  Extra details (such as rank
//     or stacks) now appear in parentheses after the description.  Console
//     messages follow the same concise format.
//   • **Description shortener** – Reviewed all boon descriptions and trimmed
//     redundant wording.  Defensive boons now use “DR stack” shorthand,
//     raising boons use "+25 max HP" / "+25 max armor", and Soul Siphon
//     reads "Heals per kill (10 s)".  XP Surge has been shortened to
//     "+50% XP (10 s)", Berserk Rite now states “Adds a Steadfast DR stack”,
//     and descriptions of damage‑at‑max‑health and minor HP raises have been
//     made succinct.
//   • **Soul Siphon timer reduced** – The base duration of Soul Siphon has
//     been decreased from 60 seconds to 10 seconds.  This encourages a more
//     frenetic playstyle and prevents the heal from trivialising early
//     encounters.  The corresponding description and HUD timer reflect
//     this change.
//   • **Carry‑over from beta 26** – Retained the Minor Raise Max Health boon,
//     Soul Siphon overheal fix, and weighted selection tweaks introduced in
//     beta 26.  These systems continue to work with the new concise
//     messaging and timer adjustments.
// - **Beta 25 – Iteration improvements**
//   • **Buff timer HUD rework** – The timed‑buff overlay now uses a larger font
//     (BigFont) and increases the bottom margin so it sits clearly above the
//     status bar.  This makes timers easier to read and better aligned with
//     the rest of the HUD.  (Ref: ZDoom Wiki — BaseStatusBar.DrawString and
//     DI_SCREEN_LEFT_BOTTOM flags【569686084692480†L52-L57】.)
//   • **MTYB messaging** – The mythical “MTYB” boon’s toast now reads
//     “MAKE THEM YOUR BITCH.” and omits the cluttered extra description.  When
//     acquired, a low‑pitched Romero head hurt sound plays (alias
//     romero_hurt → dsbossit) to give audible feedback.  (Ref: A_StartSound
//     documentation【902386242468717†L9-L19】.)
//   • **Soul Siphon heal pass** – Maintains the beta 24 overheal fix; kills
//     continue to heal above 100 HP up to the dynamic cap calculated from
//     Raise Max Health tiers.  Ensure this behaviour persists through future
//     tuning.  (Ref: PlayerPawn.GiveBody details【902386242468717†L9-L19】.)
//   • **Description cleanup** – Updated BoonDesc for MTYB and removed duplicate
//     extra text from its console message.  Future passes should audit other
//     boons for clarity and avoid repeating effect summaries in the toast.
//   • Patch notes from earlier versions remain below; consult those entries
//     for prior balancing and bug‑fix history.
// - Doc cross‑check passed (4.14.2) – verified DrawText usage in
//   StatusBarEventHandler.RenderOverlay and updated comments accordingly.
// - Bulwark shards HUD fix: The “BULWARK” line now displays your current shard count and
//   maximum (e.g., “BULWARK  2/5”), rather than an always‑zero percentage.  Shards are
//   gained on kills and consumed to reduce the next incoming hit by 30 %.  This
//   change clarifies Bulwark’s function and eliminates the 0 % bug.
//   — Effect: Improved — Conf: 94.5000%
// - Executioner & Heavy Slayer balance: Bonus damage vs low‑HP and high‑HP targets has been
//   reduced to +10 % per tier (max two tiers).  On‑hit logs report the bonus when
//   triggered, and awarding messages reflect the new percentages.  This softens
//   damage spikes and simplifies scaling.
//   — Effect: Improved — Conf: 92.0000%
// - Soul Siphon check: Retains overheal up to 200 HP with a 0.25 s cooldown, using
//   `GiveBody()` with `extraCap=true` as documented in GZDoom’s API.  Heals are
//   always logged for verification.  Further tuning may be required if mods
//   override `MaxHealth`.
//   — Effect: Neutral — Conf: 91.0000%
// - Code clean‑up & documentation: Unused boons and comments have been pruned and
//   remaining functions cross‑checked against the ZDoom 4.14.2 documentation for
//   `StatusBarEventHandler.RenderOverlay` and CVAR definitions【982810389894626†L7-L18】【246581989945189†L10-L29】.
//   This improves maintainability without altering gameplay.
//   — Effect: Neutral — Conf: 90.0000%
// - **Internal notes:** Updated constants (`DR_STAGE_BASE_MIN`,
//   `StageSkillMultiplier()`, HP table, `DR_QD_MULT`) and added an
//   immediate Soul Siphon activation message.  Stage index calculations now
//   use the 0.07× increment beyond stage 0.
//   Stage skill multipliers updated to {2.0,1.5,1.2,1.0,0.8}.  Quad Damage
//   multiplier remains at 3× for a noticeable but not overwhelming effect.
// - Slowed XP and damage growth: base XP per level increased to 90, growth
//   factor raised to 1.25, and per‑level damage bonus reduced to 2.5 %.
// - Added Soul Siphon debug logs and expiration messages, and extended kill
//   logs to include heal and buff status when active (behind `dr_dbg_hits`).
// - Tuned Berserking Firepower: global damage bonus reduced from +20 % to
//   +15 % to mitigate stacking with other damage multipliers.  Descriptions
//   and console messages updated accordingly.
// - Packaging fix: previous release accidentally shipped a truncated PK3 missing
//   monster definitions, resulting in an empty map.  This release provides the
//   ZScript as a standalone `.zs` file to be added to the original PK3 so all
//   lumps (DECORATE, TRNSLATE, etc.) remain intact. — Effect: Improved — Conf: 97.0000%.
// - Fixed PrintBoonConsole string comparison by removing invalid `null` check
//   and using `Length() > 0` instead.  This resolves the "incompatible operands"
//   error and ensures messages are printed correctly【309068861870640†L94-L100】. — Effect: Improved — Conf: 98.5000%.
// - Changed DR_TestHarness override signature to `WorldLoaded(WorldEvent e)` to match the correct event handler method. This prevents the
//   fatal 'Attempt to override non-existent virtual function WorldLoaded' error when loading the mod. — Effect: Improved — Conf: 98.5000% — [Doc: https://zdoom.org/wiki/Events_and_handlers#Functions【132873237860297†L35-L146】].
// - Fixed string comparison: PrintBoonConsole no longer compares strings to null,
//   using Length() > 0 instead; this resolves the "incompatible operands" error.
// - Removed the defense-pity counter entirely from SelectBoon(), simplifying
//   selection to a 60/25/15 weighted random over Offense/Defense/Utility boons.
//   This eliminates "Expression must be a modifiable value" errors on PityDefCtr.
// - Eliminated all DI_SCREEN_* constants and positional flags from Screen.DrawText
//   calls; positions are now absolute (bx/by and computed offsets).  This avoids
//   undefined symbol errors and matches DrawTextâs documented parameter listã950367212508399â L11-L32ã.
// - Normalized all HUD color constants to the uppercase names defined in Font
//   (e.g. CR_GOLD, CR_LIGHTBLUE, CR_GREEN); removed undefined CR_LightGreen.
// - Removed unused NetMode/NM_Client checks and deprecated toast fallback code.
// - Updated version and date; trimmed patch notes history for clarity.
// - Added DR_TestHarness event handler as a stub to satisfy MAPINFO AddEventHandlers. This CVAR-controlled class
//   currently does nothing but can be extended for smoke testing; see guidelines section 21.
// - HUD fix: top-left panel now uses st.CurrentWeaponIndex for weapon/level/XP display instead of the obsolete
//   snapshot fields. A snapshot inventory is still retrieved for toast messages (`snap`) to avoid compile errors.
//   This resolves the `Unknown identifier 'snap'` error. — Effect: Improved — Conf: 98.0%.
// - Resolved crash in PrintBoonConsole caused by String.Format() argument mismatch.  The helper now builds
//   the message via concatenation and avoids passing `%`‑rich extra strings to String.Format, preventing
//   “Not enough arguments for format” errors【960410346502109†L93-L101】. — Effect: Improved — Conf: 98.5000% — [Doc: String concatenation uses ..].
// - Balance adjustment: Reduced per‑level weapon damage (DR_DMG_PER_LVL lowered to 0.03) and tightened permanent damage boosters (DR_OVERMULT_CAP now 1.30).  XP progression slowed (XP_BASE_PER_LEVEL increased to 80, XP_GROWTH_FACTOR to 1.20, XP_PER_HP lowered to 0.10) so players level up more slowly and remain vulnerable longer. — Effect: Improved — Conf: 95.0%.
// - Stage damage scaling: Monsters now deal progressively more damage as stages advance.  The scaling logic has moved from WorldThingDamaged (where `e.Damage` is read‑only) into the `RogueStats.ModifyDamage` hook.  Incoming damage from monsters is multiplied by the current HP scale (e.g., 1.15× at stage 1) after DR reductions.  This avoids the “Expression must be a modifiable value” compile error and ensures correct scaling【307876007143943†L60-L63】. — Effect: Improved — Conf: 94.0%.
// - HUD progress bar: Added a progress bar below the stage line showing time until the next stage.  The bar fills from left to right over the stage interval (default three minutes multiplied by a skill factor) so players can anticipate difficulty jumps. — Effect: Improved — Conf: 94.5%.
// - Hit logging: The `dr_dbg_hits` CVAR logs both outgoing and incoming hits.  Incoming hits are now logged within the `ModifyDamage` hook where final damage is known.  Logs show the attacker’s class, damage dealt, player HP/armor and stage scale. — Effect: Improved — Conf: 93.5%.
//
// === Beta7 Notes (2025-09-03) ===
// * Slowed stage progression further: `DR_STAGE_BASE_MIN` is now 5.0 minutes (was 4.0).  Per‑skill stage multipliers have been adjusted to {1.5, 1.2, 1.0, 0.85, 0.65}, now returned by a helper function rather than a constant array (since ZScript forbids top‑level constant arrays).  On Ultra‑Violence this means a stage lasts 5.0×0.85 ≈ 4.25 minutes, putting you at Stage 3 (1.45×) around 15 minutes into a run instead of Stage 4 or beyond.  These adjustments make difficulty ramp‑ups less aggressive, especially at higher skills.
// * Added timed-boon diagnostics: the Tick() handler now logs when the **Blood Rite** lifesteal buff expires (alongside existing Quad Damage, XP Surge and Adrenal Shield messages).  This helps verify that timed boons start and end correctly during playtesting. — Effect: Improved — Conf: 96.0%
// * Enhanced kill logs: when `dr_dbg_hits` is enabled, kill logs now display the monster’s base and scaled HP, the current weapon level, and the stage number and scale at the time of death.  This provides immediate feedback on whether the stage timer is applying correctly. — Effect: Improved — Conf: 95.0%
// * Fixed progress bar: the bar now measures the fraction of time elapsed toward the **next** stage using the same base duration and skill multipliers as `DR_GetHPScale()`.  It resets only when a new stage begins and fills linearly toward 100%.
// * Boon messages: `RogueBoons.PrintBoonConsole()` now calls `pp.A_Log(fullMsg)` to display the “Boon Gained: …” message in the center HUD message area (the same location as “You found a secret”).  It still prints to the console for reference.
// * Tuning constants: added `DR_STAGE_SKILL_MUL` array to centralize skill factors.  Added `DR_STAGE_BASE_MIN` constant.  Progress bar and HP scaling both reference these constants for consistency.
// * Re-packed as 1.0beta6 with updated header and patch notes.  All prior fixes (Soul Siphon healing, diagnostic logs, per‑map resets, Blue Vial/Armor Bonus boons) remain intact.
// - Fix 14: Percent‑sign escape.  PrintBoonConsole now calls Console.Printf("%s", fullMsg) instead of Console.Printf(fullMsg).
//   Without a format string `%s`, Console.Printf treats percent signs in the message as format placeholders, leading to crashes
//   when messages like “+15% XP” have no matching numeric arguments.  Passing the string explicitly escapes percent signs
//   and prints the message verbatim.
//
// - Added per-player quad damage debug messages.  A new `QuadActiveNotified` field in RogueStats tracks whether
//   Quad Damage has been announced.  When Quad Damage becomes active the console prints a message showing the
//   remaining duration; when it expires another message is printed.  This helps testers verify when Quad Damage
//   is on and off without checking the HUD. — Effect: Improved — Conf: 96.0%.
// - Corrected Marine Grit boon message.  Previously the description read “-2% DR stack” despite actually
//   increasing damage reduction.  The message now reads “+2% DR stack” for clarity.  Steadfast stacks still
//   provide 10% DR per stack. — Effect: Improved clarity — Conf: 95.5%.
// - DebugOn() default behaviour unchanged: debug messages are still enabled by default when dr_dbg is unset.
// - No other functional changes; file size increase due to added field and logic (~0.3%).
// - Debugging messages: `RogueCoreHandler.DebugOn()` now defaults to true when the CVAR `dr_dbg` is unset,
//   enabling damage/XP/boon logs by default.  This aids playtesting and can still be disabled by setting `dr_dbg` to 0. — Effect: Improved — Conf: 97.0000%.
// - HUD: Migrated to StatusBarEventHandler.RenderOverlay; switched to DrawString + DI_SCREEN_LEFT_TOP.
// - HUD: Removed duplicate TIME-only line; kept single "TIME ..  STAGE .." line.
// - Cleanup: Renamed inert WeaponXP1/2 arrays to Legacy_WeaponXP1/2 (comments-only usage).
// - Checklists: Marked HUD policy compliance and array rename as CODE-complete.
// - HUD safety: Stage display now reads st.DifficultyScale (or 1.00 if unavailable) â no world calls from UI.
// - Confidence sweep: no logic changes elsewhere; preflight gates re-checked.
// - HUD: Added TIME MM:SS and STAGE (DifficultyScale) line to RogueHUD left panel.
// - Notes/checklist added for HUD section; no other behavior changed.
// - Timer stages: allow progression beyond stage 5 by continuing the +0.15 HP step each window.
// - HMP reaches stage 5 at ~15 minutes (3.0m windows Ã skill multiplier), unchanged.
// - Bug sweep: net-mode guards on mutating paths; explicit clamps (no max()); guarded weapon index.
// - Verified: no per-weapon XP arrays; no wx1/wx2/wxp; unified difficulty function in use.
// - Added DR CHECKLIST blocks with user/code confirmations for core systems (comments only).
// - No logic changes; preserves 0.5.259 behavior.
// - Added structured DR NOTE bookmarks across core systems (dated, versioned, confidence, completion, futures).
// - Clean pass to standardize notes; no behavior changes.
// - Retained 0.5.258 XP/difficulty unification and pacing.
// - XP pacing tuned: XP_PER_HP=0.12 (was 0.15), XP_MAX_PER_KILL=200 (was 250).
// - Unified difficulty scaling: spawn & UI now use 5-stage DR_GetHPScale(); no double-scaling.
// - Spawned monsters get DR_MonHPScale initialized to current stage to enable clean future sweeps.
// - AddXP debug string fixed to show (Global, Timed, Total) only.
// - Big-clean pass: removed toast fallbacks (console-only UX), enforced case breaks in ApplyBoon.
// - Added DR_SAVE_VER placeholder constant for future Serialize (no behavior change).
// - Clamped OverMult after all multipliers; standardized level-up console text.
// - Core 8 + weighted picker + defense pity retained from 0.5.256.
// - Simplified boon set to Core 8 via aliasing; old IDs map to core effects.
// - Weighted picker (60% Offense / 25% Defense / 15% Utility) with Defense pity after 3 misses.
// - Per-weapon Damage Booster clamped: DR_OVERMULT_CAP=1.50; UAC Overcharger = +15% (clamped).
// - Console boon lines include brief numeric details.
// - XP math: all XP-affecting boons are universal (GlobalXPMult/TimedXPMult only).
// - DRB_Legacy_WeaponXP1 now +5% global XP; DRB_Legacy_WeaponXP2 +10% global XP; both clamp at 3.0x.
// - AddXP debug simplified to (Global, Timed, Total) factors; per-weapon WX removed.
// - Implement all missing boons; add names/descs.
// - Balance: DamageBooster now +3% (was +25%).
// - Keep console-only level-up + boon messages.
// - HUD now reads ReadyWeapon for name/xp/level; fixes Fist label & frozen XP bar. â Effect: Improved â Conf: 0.93
// - Centered toasts restored: Weapon Level Up + Boon Gained (name + description). â Effect: Improved â Conf: 0.91
// - Balance: per-level damage 4% (was 7%); soft cap 2.0, hard cap 3.5; Power Up boon 1.05x. â Effect: Improved â Conf: 0.85
// - No movement/DoT changes; launchability preserved; file stays single-lump. â Effect: Neutral â Conf: 0.98
// - Doc cross-check passed (4.14.2). Patch Notes review completed.
class DRPatchHelpers
{
    static double Clampd(double v, double lo, double hi)
    {
        if (v < lo) return lo;
        if (v > hi) return hi;
        return v;
    }

    // Discrete minute-based power growth: base^floor(minutes)
    static double PowdMinutes(double base, double minutes)
    {
        int m = int(minutes);
        if (m <= 0) return 1.0;
        double r = 1.0;
        for (int i = 0; i < m; i++) r *= base;
        return r;
    }

    static double Powd(double base, int n)
    {
        if (n <= 0) return 1.0;
        double r = 1.0;
        for (int i = 0; i < n; i++) r *= base;
        return r;
    }

    // Return the multiplier for stage timing based on skill index.
    // Skill indices: 0=ITYTD, 1=HNTR, 2=HMP, 3=UV, 4=Nightmare.  Multipliers
    // greater than 1 slow progression; values below 1 speed it up.  This helper
    // avoids the need for a top‑level constant array (which ZScript does not
    // support) and centralizes the values for use in both DR_GetHPScale() and
    // HUD rendering.
    static double StageSkillMultiplier(int sk)
    {
        // Stage timers for beta 13.  These multipliers are applied to
        // DR_STAGE_BASE_MIN to produce the number of minutes per stage on
        // each difficulty.  ITYTD has the slowest progression, while
        // Nightmare speeds it up.  UV now uses the base value (3 min) so
        // Stage 1 → Stage 2 occurs at 3 minutes.  See the patch notes for
        // details.
        if (sk <= 0) return 2.0;      // ITYTD  – 6 min per stage (2× base)
        if (sk == 1) return 1.5;      // HNTR   – 4.5 min per stage
        if (sk == 2) return 1.2;      // HMP    – 3.6 min per stage
        if (sk == 3) return 1.0;      // UV     – 3 min per stage
        // Nightmare or any higher value
        return 0.8;                   // NM     – 2.4 min per stage
    }
}

// -------------------------- CONSTANTS -------------------------------------
// NOTE: top-level consts untyped for 4.14.x (no 'int/double/bool' keywords).

const DR_MAX_HEALTH_CAP = 200;
const DR_MAX_ARMOR_CAP = 200;

// XP progression tuning for beta 8.  Increase the base requirement and growth
// factor so that weapon levels come more slowly, preventing early runaway
// scaling.  Weapons now require 90 XP at level 1 and scale by 1.25× per level.
const XP_BASE_PER_LEVEL = 90;
const XP_GROWTH_FACTOR = 1.25;

// Damage per‑level tuning.  Slightly reduce the per‑level multiplier to
// prevent player damage from overtaking monster scaling too quickly.
const DR_DMG_PER_LVL = 0.025;
const DR_DMG_SOFTCAP = 2.00; // unchanged; soft cap at 2×
const DR_DMG_TAPER   = 0.20; // unchanged; taper beyond the soft cap
const DR_DMG_HARDCAP = 3.50; // unchanged; absolute maximum multiplier

// Soul Siphon tuning.  When acquired, the player gains Soul Siphon for
// DR_SS_BASE_DURATION seconds.  During this time each qualifying kill heals
// SoulSiphonLevel HP.  SoulSiphonLevel increases by one each time the boon is
// acquired up to DR_SS_MAX_RANK.  Overheal is allowed (cap at 200).
// Soul Siphon base duration (seconds).  The effect should be brief to
// encourage aggressive play.  In beta 27 this has been reduced from
// sixty seconds to ten seconds, so Soul Siphon heals are time‑limited
// and require frequent kills to maintain.  See BoonDesc() for the
// corresponding description text.
const DR_SS_BASE_DURATION = 10.0; // seconds
const DR_SS_MAX_RANK = 5;

// === DR NOTE [0.5.259] â 2025-09-02 19:52:47 EDT â Section: Constants â XP pacing & Timer Stages ===
// Confidence: 99.3000% | Completion: 98%
// Future attacks:
//  â¢ Expose XP_PER_HP & XP_MAX_PER_KILL as CVARs (read at level start) if live tuning desired
//  â¢ Consider skill-based XP multipliers (tiny): ITYTD 0.9 â NM 1.1
//  â¢ Stage table CVAR gate for experiments; default stays locked
// Bookmarks: [DR_NOTE_ConstantsXPpacingTimerStages]
const XP_PER_HP = 0.10;
const XP_MIN_PER_KILL = 8;
const XP_MAX_PER_KILL = 200;

const LEVELUP_TICS = 350;

const DR_TIMER_PAUSE_IN_INTERMISSION = 1;
const DR_TIMER_PAUSE_IF_NO_PLAYERS = 1;

const DR_DIFFICULTY_BASE = 1.00;
const DR_DIFFICULTY_PER_MINUTE_EXPONENT = 1.01;  // ~1% per minute (discrete)
const DR_DIFFICULTY_MAX_SCALE = 1.75;  // hard cap: +75% max
const DR_DIFFICULTY_HEALTH_MULT = 1.00;
const DR_DIFFICULTY_SPEED_MULT = 0.00;  // safety: keep 0 (no speed scaling)
const DR_DIFFICULTY_DAMAGE_MULT = 1.00;  // safety: keep 1 (no damage scaling)

const DR_SKILL_TIME_MUL_ITYTD = 0.80;
const DR_SKILL_TIME_MUL_HNTR = 0.90;
const DR_SKILL_TIME_MUL_HMP = 1.00;
const DR_SKILL_TIME_MUL_UV = 1.12;
const DR_SKILL_TIME_MUL_NM = 1.25;

// --- Soul Siphon / per-map healing limit ---
// Maximum number of Soul Siphon heals permitted per map.  Each qualifying
// kill replenishes one HP up to this limit; the counter resets on level
// load via ResetPerMapCaps().  Defining this as a top-level constant avoids
// declaring const inside a method (which ZScript forbids) and makes tuning
// easier.
const DR_SS_MAX_PER_MAP = 10;

// --- New boon tuning constants for beta 18 ---
// Executioner: bonus damage vs low HP enemies.  Apply when a target is at or below
// DR_EXEC_THRESHOLD of its max HP.  Two tiers grant +20% and +40% damage,
// applied as additional damage after the base hit.  See WorldThingDamaged for
// implementation.
const DR_EXEC_THRESHOLD = 0.20;
// Executioner per‑tier bonuses: +10% and +20% to reduce runaway scaling.  Ref: user feedback.
const DR_EXEC_BONUS1   = 0.10;
const DR_EXEC_BONUS2   = 0.20;

// Heavy Slayer: bonus damage vs high-HP enemies.  Applies when the target's
// spawn health is at least DR_HEAVY_MIN_HP.  Two tiers grant +15% and +25%
// additional damage, applied after the base hit.
const DR_HEAVY_MIN_HP  = 300;
// Heavy Slayer per‑tier bonuses: +10% and +20% vs high‑HP enemies.  Ref: user feedback.
const DR_HEAVY_BONUS1  = 0.10;
const DR_HEAVY_BONUS2  = 0.20;

// Crowd Frenzy: chain kills grant a short damage buff.  Each successive kill
// within DR_FRENZY_KILL_WINDOW seconds grants one stack, up to
// DR_FRENZY_MAX_STACKS.  Each stack adds DR_FRENZY_PER_STACK to outgoing
// damage while DR_FRENZY_BUFF_DURATION seconds remain.  Timers are in
// seconds; multiply by TICRATE when converting to tics.
const DR_FRENZY_PER_STACK   = 0.08;
const DR_FRENZY_MAX_STACKS  = 5;
const DR_FRENZY_KILL_WINDOW = 3.0;
const DR_FRENZY_BUFF_DURATION = 6.0;

// Bulwark Shards: each shard reduces the next incoming hit by this factor.
// See ModifyDamage for consumption logic.
const DR_BULWARK_SHARD_DR = 0.30;

// Stage Tamer: slows down stage progression.  Each tier multiplies the base
// stage duration by (1 + DR_STAMER_SLOWn).  Tier 1: 10% longer stages; Tier 2:
// 15% longer.
const DR_STAMER_SLOW1 = 0.10;
const DR_STAMER_SLOW2 = 0.15;

// Maximum stacks granted by the Blue Vial Mastery and Armor Bonus Mastery boons.
// These caps prevent runaway healing/armor scaling.  Each boon pick increases
// its respective stack by one up to the limit.  When picking beyond the cap,
// the stack remains at the cap and no further effect is applied.
const DR_BLUEVIAL_MAX = 5;
// Armor Bonus Mastery: each tier increases the bonus armor granted by the
// standard ArmorBonus item.  Previous betas capped this at 5 stacks; in
// beta 22 the cap has been increased to 10 so players can meaningfully
// invest in armor sustain.  See DR_ArmorBonusProxy for details.
const DR_ARMORBONUS_MAX = 10;

const DR_DR_CAP = 0.75;
// Per-stack damage reduction for Marine Grit (Steadfast) boon.
// Beta 13 reduces this from 10% to 5% per stack to slow damage
// reduction accumulation and prevent players from capping DR too quickly.
const DR_STEADFAST_PERSTACK = 0.05;
// Bulwark damage reduction values per stack.  The first two stacks grant
// 10% DR each; the third stack grants 5%.  This totals 25% when fully
// stacked.  Previously values were 0.15, 0.15, 0.05 resulting in 35%,
// which contributed to excessively high DR.
const DR_BULWARK_S1 = 0.10;
const DR_BULWARK_S2 = 0.10;
const DR_BULWARK_S3 = 0.05;

const DR_ADRENAL_DR = 0.50;
const DR_ADRENAL_SECONDS = 6.0;

const DR_OC_BONUS_MULT = 1.12;
const DR_OC_MIN_LEVEL_SPACING = 3;
const DR_LEGENDARY_MIN_LVL = 9;

// Knockback scale factor.  Vanilla DOOM applies a thrust proportional to the
// inflicted damage divided by the target’s mass.  High‑damage weapons and
// scaled damage can launch light monsters unrealistically far.  Multiply the
// target’s horizontal velocity by this constant after damage to restore a
// more classic knockback feel.  Values less than 1 reduce knockback; values
// greater than 1 amplify it.  Not applied to vertical velocity so jump arcs
// remain intact.
const DR_KNOCKBACK_SCALE = 0.35;

// Stage progression tuning.  The base number of minutes between stage increases and
// skill multipliers are defined here so both DR_GetHPScale() and the HUD
// progress bar can reference the same values.  Stage difficulty increases occur
// every `DR_STAGE_BASE_MIN * DR_STAGE_SKILL_MUL[skill]` minutes.  Adjust these
// values to fine‑tune how quickly difficulty ramps up per skill level.  See
// [Ref: ZDoom Wiki — CVAR and skill notes] for skill indices (0=ITYTD..4=Nightmare).
// Stage progression tuning.  Base number of minutes between stage increases
// (risk‑style difficulty scaling).  Setting this higher slows the rate at
// which new stages occur.  In beta6 this has been increased from 4 minutes
// to 5 minutes to further smooth out the difficulty curve.  A subsequent
// update may expose this as a CVAR for live tuning.
// Base number of minutes between stage increases.  Higher values slow the
// rate at which monsters gain HP and damage.  In beta 11 this has been
// increased to 7 minutes (from 5) to give players more breathing room
// before difficulty ramps up.
const DR_STAGE_BASE_MIN = 3.0;

// Skill multipliers for the stage timer.  Instead of a constant array (which is
// unsupported at the top level), expose a helper function that returns the
// appropriate multiplier for a given skill index.  Multipliers greater than 1
// slow down stage progression; values less than 1 speed it up.  The values
// chosen here slow high‑skill games: ITYTD=1.5, HNTR=1.2, HMP=1.0, UV=0.85,
// NM=0.65.


const DR_RO_GLOBAL_DMG = 1.00;

// === New constants for beta 22 ===
// Increment amount when raising maximum health.  Each Raise Max Health boon
// grants +25 to the maximum health the player can be healed to.  The base
// cap is 200 (vanilla DOOM) and additional increments stack until the
// ultimate cap of 666.  Do not modify DR_MAX_HEALTH_CAP to avoid
// interfering with default healing items; instead compute dynamic caps at
// runtime using these values.
const DR_RAISE_HEALTH_INC = 25;
const DR_RAISE_HEALTH_CAP = 666;
// Increment amount when raising maximum armour.  Each Raise Max Armour boon
// grants +25 to the maximum armour the player can be healed to.  The base
// cap is 200 and additional increments stack until the cap of 666.
const DR_RAISE_ARMOR_INC = 25;
const DR_RAISE_ARMOR_CAP = 666;

// Increment added by the Minor Raise Max Health boon.  Each minor tier adds
// five points to the player’s maximum healable health.  A handful of these
// boons will extend the cap gradually without overshooting the overall
// cap defined by DR_RAISE_HEALTH_CAP.  See HealCapped() for cap logic.
const DR_RAISE_HEALTH_MINI_INC = 5;
// Extra damage applied when the player is at full health (including raised
// caps).  When the Extra Damage At Max Health boon is active and the
// player’s current health equals their dynamic maximum, outgoing damage is
// multiplied by (1 + DR_MAXHEALTH_DMG_BONUS).
const DR_MAXHEALTH_DMG_BONUS = 0.25;
// Global damage bonus granted by the Berserking Firepower boon.  This value
// is added multiplicatively to all outgoing damage.  To avoid stacking too
// strongly with other damage multipliers (level, over, quad, frenzy, etc.),
// the bonus has been reduced from +20 % to +15 % in beta 23.  Stacks are
// still not supported; awarding the boon multiple times has no effect.
const DR_BERSERK_FIREPOWER_BONUS = 0.15;

// Quad Damage multiplier.  Increase to 2.50 for beta 9 so Quad Damage hits
// harder (base damage × level × over × global × quad).  This remains within
// the spirit of DOOM without becoming overwhelmingly overpowered.
// Quad Damage multiplier.  Increased to 3.0× for beta 11 to make Quad
// Damage feel more impactful in the mid‑game.  This value multiplies
// outgoing damage in RogueStats.ModifyDamage() when QuadTics > 0.
const DR_QD_MULT = 3.00;
// Quad Damage base duration in seconds.  Reduced from the original 20 s to
// 15 s to provide a noticeable but balanced burst of power.  This value is
// used when awarding Quad Damage and when computing its on‑screen timer.
const DR_QD_SECONDS = 15.0;

const DR_BR_LIFESTEAL = 0.40;
const DR_BR_SECONDS = 10.0;

const DR_LEG_INVUL_SEC = 15.0;

const DR_VIAL_CAP = 15;
const DR_ABONUS_CAP = 15;

const DR_STIM_TMAX = 5;
const DR_MEDI_TMAX = 3;
const DR_STIM_PER_T = 20;
const DR_MEDI_PER_T = 60;

const DR_XP1_CAP = 25;
const DR_XP2_CAP = 15;
const DR_XPRUSH_SEC = 120;


// ZScript constants do not allow an explicit type; the type is inferred from the value.
const DR_OVERMULT_CAP = 1.30; // cap for permanent per-weapon damage bonus (reduced)
// ZScript constants do not specify a type; the type is inferred from the assigned value.
// Remove the explicit 'int' keywords to conform with ZScript constant syntax.
const DR_PITY_DEF_WIN = 3;        // picks without defense before pity forces a Defense roll
const DR_CAT_OFFENSE = 1;
const DR_CAT_DEFENSE = 2;
const DR_CAT_UTILITY = 3;
const DR_SAVE_VER = 1; // Save schema placeholder (no Serialize yet)
const DR_XP_GLOBAL_STEP = 1.15;
const DR_XP_GLOBAL_MAXSTK = 5;
const DR_XP_GLOBAL_MTYB = 1.50;

const DR_SCBOOST_MAX = 3;


// -------------------------- TAG ITEMS -------------------------------------

// --- Difficulty hotfix: stop monsters from gaining outgoing damage ---
// Keep HP/timer tags intact; only neutralize damage scaling.

class DR_SpawnHP : Inventory
{
    Default
    {
        +Inventory.Undroppable;
        +Inventory.NeverRespawn;
        +Inventory.Quiet;
        Inventory.MaxAmount 32767;
        Inventory.PickupMessage "";
    }
}

class DR_TimerScaled : Inventory
{
    Default
    {
        +Inventory.Undroppable;
        +Inventory.NeverRespawn;
        +Inventory.Quiet;
        Inventory.MaxAmount 1;
        Inventory.PickupMessage "";
    }
}

class DR_StatHolder : Inventory
{
    Default
    {
        +Inventory.Undroppable;
        +Inventory.NeverRespawn;
        +Inventory.Quiet;
        Inventory.MaxAmount 32767;
        Inventory.PickupMessage "";
    }

    // Hotfix: pass damage through unchanged so monsters don't get damage buffs.
override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
    {
        newdamage = damage;
        return;
    }
}

class DR_Invul_Short  : PowerInvulnerable { Default { +Inventory.AutoActivate; +Inventory.Quiet; Inventory.MaxAmount 0x7fff; Powerup.Duration 35; } }
class DR_Invul_Legend : PowerInvulnerable { Default { +Inventory.AutoActivate; +Inventory.Quiet; Inventory.MaxAmount 0x7fff; Powerup.Duration int(DR_LEG_INVUL_SEC*35); } }

// -------------------------- WEAPON ENUM -----------------------------------
enum RogueWeaponIndex { RW_Fist = 0, RW_Chainsaw, RW_Pistol, RW_Shotgun, RW_SuperShotgun, RW_Chaingun, RW_RocketLauncher, RW_PlasmaRifle, RW_BFG9000, RW_Count }

// -------------------------- UTIL ------------------------------------------
class RogueUtil
{
    static int Powi(int b, int exp) { int r = 1; for (int i=0;i<exp;i++) r*=b; return r; }
    static double Powd(double b, int exp) { double r = 1.0; for (int i=0;i<exp;i++) r*=b; return r; }

    static int WeaponToIndex(Weapon w)
{
    if (w == null) return -1;
    class<Weapon> wc = w.GetClass();
    if (wc == 'Fist') return RW_Fist;
    if (wc == 'Chainsaw') return RW_Chainsaw;
    if (wc == 'Pistol') return RW_Pistol;
    if (wc == 'Shotgun') return RW_Shotgun;
    if (wc == 'SuperShotgun') return RW_SuperShotgun;
    if (wc == 'Chaingun') return RW_Chaingun;
    if (wc == 'RocketLauncher') return RW_RocketLauncher;
    if (wc == 'PlasmaRifle') return RW_PlasmaRifle;
    if (wc == 'BFG9000') return RW_BFG9000;
    return -1;
}

    static String IndexToName(int idx)
{
    switch(idx)
    {
        case RW_Fist: return "FIST";
        case RW_Chainsaw: return "CHAINSAW";
        case RW_Pistol: return "PISTOL";
        case RW_Shotgun: return "SHOTGUN";
        case RW_SuperShotgun: return "SUPER SHOTGUN";
        case RW_Chaingun: return "CHAINGUN";
        case RW_RocketLauncher: return "ROCKET LAUNCHER";
        case RW_PlasmaRifle: return "PLASMA RIFLE";
        case RW_BFG9000: return "BFG9000";
        default: return "";
    }
}


    ui static String IndexToName_UI(int idx) { return IndexToName(idx); }

    static int XPForVictim(Actor victim)
    {
        if (victim == null) return 0;
        int maxhp = victim.SpawnHealth();
        DR_SpawnHP tag = DR_SpawnHP(victim.FindInventory('DR_SpawnHP'));
        if (tag && tag.Amount > maxhp) maxhp = tag.Amount;
        if (maxhp < 1) maxhp = 1;
        int xp = int(int(maxhp) * XP_PER_HP + 0.5);
        return DRPatchHelpers.Clampd(xp, XP_MIN_PER_KILL, XP_MAX_PER_KILL);
    }
}

// -------------------------- RUN DATA --------------------------------------
class RogueStats : Inventory
{
    transient int PityDefCtr; transient int LastBoonCat;

    transient int LastWpnIdx;
    transient int LastWpnTick;
    int DRSeedState; int DRSeedOrigin;
    bool StatsInit;
    int LvlupSeen, BoonCheatSeen;
    int Level[RW_Count], XP[RW_Count];
    int LastLeveledIndex, LevelUpTics, LastLeveledOldLevel, LastLeveledNewLevel, LastDmgOldPct, LastDmgNewPct;
    int RunTimerSec;
    double DifficultyScale;

    double GlobalXPMult; int AccelStacks;
    int    TimedXPTics;  double TimedXPMult;
    double GlobalDmgMult; int QuadTics;

    int LegendaryCD, MythicCD;
    bool BloodRiteOwned; int BloodRiteTics;

    int StimTier, MedikitTier, BlueVialStacks, ArmorBonusStacks;
    int SuperchargeStacks;

    int Boon_SteadfastStacks, Boon_BulwarkStacks;
    bool Boon_AdrenalShield; int AdrenalShieldTics;

    bool Boon_AegisFrame;
    bool Boon_SoulSiphon; int Boon_SoulSiphonUsed;
    int Boon_ArmorReinfI, Boon_ArmorReinfII;
    bool Boon_SecurityMk2, Boon_CombatMk3;

    // Debug flag: tracks whether Quad Damage activation has been announced for this player.  When QuadTics
    // transitions from zero to positive this will be set to true and a message printed.  When QuadTics
    // returns to zero it is reset and another message is printed.  This does not affect gameplay.
    bool QuadActiveNotified;

    // Soul Siphon timed buff: when Soul Siphon is active, this counter holds
    // the remaining duration in tics (1/35th of a second).  SoulSiphonLevel
    // controls how much health is restored per kill (1..DR_SS_MAX_RANK).
    int SoulSiphonTics;
    int SoulSiphonLevel;
    bool SoulSiphonNotified;

    // Cooldown timer for Soul Siphon heals (in tics).  To prevent kill spam
    // granting multiple heals within the same frame, a 0.25 s internal cooldown
    // is applied whenever a heal occurs.  Heals will only trigger when this
    // counter reaches zero.
    int SoulSiphonCDTics;

    // ===== New boon state =====
    // Executioner: number of tiers acquired (0–2).  Each tier grants
    // additional damage vs low‑HP enemies.
    int ExecutionerLevel;

    // Heavy Slayer: number of tiers acquired (0–2).  Each tier grants
    // bonus damage vs high‑HP enemies.
    int HeavySlayerLevel;

    // Stage Tamer: number of tiers acquired (0–2).  Each tier slows stage
    // progression by 10% or 15% respectively.
    int StageTamerLevel;

    // Bulwark Shards: tier (1–4) determines how many shards are gained per
    // kill and the maximum number of shards carried.  Shards reduce the
    // next incoming hit by a fixed percentage.  Shards are consumed one at
    // a time.
    int BulwarkShardLevel;
    int BulwarkShardCount;
    int BulwarkShardMax;

    // Crowd Frenzy: whether the player owns the Frenzy boon.  When true,
    // kills within a small window grant a stacking damage buff.  Frenzy
    // stacks and timers control the buff duration and chain window.
    bool FrenzyOwned;
    int FrenzyStacks;
    int FrenzyKillWindowTics;
    int FrenzyBuffTics;

    // === New persistent stat fields for beta 22 ===
    // Raise Max Health: each tier adds DR_RAISE_HEALTH_INC to the player’s
    // maximum healable health.  The base maximum is 200 HP (the
    // vanilla DOOM cap).  MaxHealthBonus counts the number of tiers
    // acquired via the Raise Max Health boon.
    int MaxHealthBonus;
    // Raise Max Armour: each tier adds DR_RAISE_ARMOR_INC to the player’s
    // maximum armour.  The base maximum is 200.  MaxArmorBonus
    // counts the number of tiers acquired via the Raise Max Armour boon.
    int MaxArmorBonus;

    // Minor Raise Max Health: counts the number of minor HP raise boons
    // acquired.  Each point adds DR_RAISE_HEALTH_MINI_INC to the player’s
    // healable health.  This value is factored into the dynamic HP cap in
    // HealCapped() and Soul Siphon logging.
    int MinorHealthBonus;
    // Extra Damage at Max Health: when non‑zero, apply a flat
    // DR_MAXHEALTH_DMG_BONUS to outgoing damage when the player is at full
    // health (including raised caps).  This is awarded by the
    // MaxHealthDamage boon.
    bool MaxHealthDamage;
    // Berserking Firepower: when true, apply DR_BERSERK_FIREPOWER_BONUS to
    // all outgoing damage.  This is awarded by the Berserking
    // Firepower boon.  Stacks are not currently supported.
    bool BerserkFirepower;
    // Time Rewind used: counts how many times the Time Rewind boon has
    // been applied during this run.  Used to throttle repeated rewinds.
    int TimeRewindUsed;

    double OverMult[RW_Count];
    int OverLastLvl[RW_Count], OverCoilCount[RW_Count];
    int Legacy_WeaponXP1[RW_Count], Legacy_WeaponXP2[RW_Count];
    double WeaponXPMult[RW_Count];

    int CurrentWeaponIndex;

    Default { +INVENTORY.PERSISTENTPOWER; +INVENTORY.UNDROPPABLE; +INVENTORY.QUIET; +INVENTORY.KEEPDEPLETED; Inventory.MaxAmount 1; Inventory.PickupMessage ""; }
    override void BeginPlay()
    {
        Super.BeginPlay();
        if (!StatsInit)
        {
            // Initialise global multipliers.  TimedXPMult defaults to 1.0 (no bonus)
            // and will be increased by XP Surge boons.  Previously this was set
            // to 2.0, which unintentionally doubled XP and broke HUD display.
            GlobalXPMult = 1.0;
            GlobalDmgMult = 1.0;
            TimedXPMult = 1.0;
            for (int i = 0; i < RW_Count; i++) { OverMult[i] = 1.0; }
            StatsInit = true;
            // Initialize Soul Siphon fields.  Level zero indicates the boon
            // has not been acquired yet.  Timers are measured in tics.
            SoulSiphonTics = 0;
            SoulSiphonLevel = 0;
            SoulSiphonNotified = false;
            SoulSiphonCDTics = 0;

            // Initialise new boon state
            ExecutionerLevel = 0;
            HeavySlayerLevel  = 0;
            StageTamerLevel   = 0;
            BulwarkShardLevel = 0;
            BulwarkShardCount = 0;
            BulwarkShardMax   = 0;
            FrenzyOwned       = false;
            FrenzyStacks      = 0;
            FrenzyKillWindowTics = 0;
            FrenzyBuffTics    = 0;

            // Initialise new boon state for beta 22/26
            MaxHealthBonus   = 0;
            MaxArmorBonus    = 0;
            MinorHealthBonus = 0;
            MaxHealthDamage  = false;
            BerserkFirepower = false;
            TimeRewindUsed   = 0;
}
    }

    // Advance timers each tick.  This override decrements the internal
    // cooldown for Soul Siphon heals so that kills cannot grant multiple
    // heals on the same frame.  It also decrements any Crowd Frenzy timers
    // if those boons are implemented in the future.
    override void Tick()
    {
        Super.Tick();
        if (SoulSiphonCDTics > 0) SoulSiphonCDTics--;
        // Decrement timers for crowd frenzy kill window and buff duration.  If
        // either reaches zero, the corresponding state naturally resets.
        if (FrenzyKillWindowTics > 0) FrenzyKillWindowTics--;
        if (FrenzyBuffTics > 0) FrenzyBuffTics--;
        if (FrenzyBuffTics <= 0 && FrenzyStacks > 0)
        {
            // When the buff expires, reset stacks so the next chain starts fresh.
            FrenzyStacks = 0;
        }
    }
    void ResetPerMapCaps() { Boon_SoulSiphonUsed = 0; SoulSiphonCDTics = 0; }

// === DR NOTE [0.5.259] â 2025-09-02 19:52:47 EDT â Section: XP System â AddXP() ===
// Update [0.5.265] â 2025-09-02 23:22:05 EDT: Renamed inert arrays to Legacy_WeaponXP1/2 for clarity; no logic change.
// === DR CHECKLIST [0.5.260] â 2025-09-02 19:55:49 EDT â AddXP() ===
// [x] CODE: XP_PER_HP=0.12; XP_MAX_PER_KILL=200; XP_MIN_PER_KILL=8
// [x] CODE: Debug string prints (Global, Timed, Total) only
// [ ] USER: XP feels consistent across enemy tiers (no runaways early)
// [ ] FUTURE: Expose dr_xp_per_hp / dr_xp_kill_cap CVARs (default locked)
// Confidence: 99.2000% | Completion: 95%
// Future attacks:
//  â¢ Keep formula GlobalXPMult Ã TimedXPMult only
//  â¢ Guard against negative amounts; clamp to â¥0 just in case
//  â¢ Optional: emit DR dbg event when clamped by MAX per kill
// Bookmarks: [DR_NOTE_XPSystemAddXP]
    play int AddXP(int widx, int amount)
    {
        if (widx < 0 || widx >= RW_Count || amount <= 0) return 0;

        double mul = 1.0;
        if (GlobalXPMult > 0) mul *= GlobalXPMult;
        if (TimedXPTics > 0 && TimedXPMult > 0) mul *= TimedXPMult;
        /* universal XP: per-weapon WX multipliers removed */

        if (RogueCoreHandler.DebugOn())
        {
            PlayerPawn pp_owner = PlayerPawn(Owner);
            double gxp = (GlobalXPMult > 0) ? GlobalXPMult : 1.0;
            double txp = (TimedXPTics > 0 && TimedXPMult > 0) ? TimedXPMult : 1.0;
            String msg = String.Format("[DR XP] Base:%d  Final:%d  %s  (Global:%.2fx  Timed:%.2fx  Total: %.2fx)", amount, int(int(amount)*mul + 0.5), RogueUtil.IndexToName(widx), gxp, txp, (gxp*txp));
            if (pp_owner) pp_owner.A_Log(msg); else Console.Printf(msg);
        }

        int gain = int(int(amount) * mul + 0.5);
        if (gain < 1) gain = 1;

        int before = Level[widx];
        XP[widx] += gain;

        while (true)
        {
            int need = RogueXP.RequiredForNext(Level[widx], widx);
            if (XP[widx] < need) break;

            XP[widx] -= need;

            LastLeveledOldLevel = Level[widx]++;
            LastLeveledNewLevel = Level[widx];
            LastLeveledIndex = widx; LevelUpTics = LEVELUP_TICS;

            LastDmgOldPct = int(RogueDamage.MultForLevel(LastLeveledOldLevel) * 100.0 + 0.5);
            LastDmgNewPct = int(RogueDamage.MultForLevel(LastLeveledNewLevel) * 100.0 + 0.5);

            PlayerPawn pp = PlayerPawn(Owner);
            if (pp) pp.A_Log(String.Format("Weapon: Level Up! (Lvl %d)", Level[widx]));
if (BloodRiteOwned) BloodRiteTics = int(DR_BR_SECONDS * TICRATE + 0.5);
            if (pp) RogueBoons.OnLevelUp(pp, self, widx, Level[widx]);
            if (LegendaryCD > 0) LegendaryCD--; if (MythicCD > 0) MythicCD--;

}
        return Level[widx] - before;
    }

override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
    {
        newdamage = damage;
        if (damage <= 0) return;

        PlayerPawn pp = PlayerPawn(Owner);
        if (pp == null) return;

        if (!passive)
        {
            // OUTGOING: player deals damage
            int widx = RogueCoreHandler.SnapWeaponIndex(pp);
            LastWpnIdx = widx; LastWpnTick++;
double lvlMult    = RogueDamage.MultForLevel(Level[widx]);
            double overMult   = RogueBoons.OverMultFor(self, widx);
            double globalMult = (GlobalDmgMult > 0.0) ? GlobalDmgMult : 1.0;
            double quadMult   = (QuadTics > 0) ? DR_QD_MULT : 1.0;
            // Apply crowd frenzy bonus if active.  Each Frenzy stack adds
            // DR_FRENZY_PER_STACK to the outgoing multiplier while the buff
            // duration is active.  Do not exceed the maximum stack count.
            double frenzyMult = 1.0;
            // Apply crowd frenzy bonus from the player's own Frenzy fields.  Do not
            // reference an undefined 'st' here; FrenzyBuffTics and FrenzyStacks are
            // fields of the current RogueStats instance.  This resolves the
            // “Unknown identifier 'st'” compile error seen when loading beta 18.
            if (FrenzyBuffTics > 0 && FrenzyStacks > 0)
            {
                frenzyMult += DR_FRENZY_PER_STACK * double(FrenzyStacks);
            }
            // Apply Berserking Firepower and Max‑Health damage bonuses.  These multipliers
            // are applied after level, over, global, quad and frenzy multipliers.
            double berserkMult = (BerserkFirepower) ? (1.0 + DR_BERSERK_FIREPOWER_BONUS) : 1.0;
            // Max‑Health bonus applies when the player is at their dynamic maximum
            // health (base 200 plus Raise Max Health tiers).  Compute cap and
            // compare against current health.  If the player is at or above
            // this cap and the MaxHealthDamage flag is set, apply the bonus.
            double maxhpMult = 1.0;
            if (MaxHealthDamage)
            {
                int cap = 200 + MaxHealthBonus * DR_RAISE_HEALTH_INC;
                if (cap > DR_RAISE_HEALTH_CAP) cap = DR_RAISE_HEALTH_CAP;
                if (pp.health >= cap)
                {
                    maxhpMult += DR_MAXHEALTH_DMG_BONUS;
                }
            }
            double totalMult  = lvlMult * overMult * globalMult * quadMult * frenzyMult * berserkMult * maxhpMult;
            newdamage = int(ceil(double(damage) * totalMult));
            if (RogueCoreHandler.DebugOn())
            {
                int baseD = damage;
                int finalD = newdamage;
                String wnm = RogueUtil.IndexToName(RogueCoreHandler.SnapWeaponIndex(pp));
// === DR NOTE [0.5.259] â 2025-09-02 19:52:47 EDT â Section: Damage Calc â Outgoing multipliers ===
// === DR CHECKLIST [0.5.260] â 2025-09-02 19:55:49 EDT â Damage Calc â Outgoing ===
// [ ] REVIEW: DR_DMG_PER_LVL set to 0.06 (6% per level) â verify constant in RogueDamage
// [ ] REVIEW: âOther weapons +3% per level-upâ applied once globally
// [x] CODE: OverMult[w] clamps to 1.50Ã
// Confidence: 99.0000% | Completion: 95%
// Future attacks:
//  â¢ Confirm DR_DMG_PER_LVL final value (target 6%/lvl)
//  â¢ Verify 'other weapons +3%' global is applied once per level-up
// Bookmarks: [DR_NOTE_DamageCalcOutgoingmultipliers]
                Console.Printf( String.Format("[DR DMG OUT] %s base:%d -> %d  (lvl:%.2f over:%.2f global:%.2f quad:%.2f frenzy:%.2f total:%.2f)",
                    wnm, baseD, finalD, lvlMult, overMult, globalMult, quadMult, frenzyMult, totalMult));
            }
        }
        else
        {
            // INCOMING: player receives damage
            double dr_total = RogueBoons.DR_Total(self);
            int nd = damage;
            // Apply damage reduction from boons
            if (dr_total > 0.0)
            {
                nd = int(ceil(double(nd) * (1.0 - dr_total)));
                if (nd < 0) nd = 0;
            }
            // Consume a Bulwark shard if available.  Each shard reduces the damage of a single incoming hit
            // by a fixed percentage (DR_BULWARK_SHARD_DR).  The shard count is decremented and a log is
            // printed for testers to verify the effect.  Apply after damage reduction but before stage scaling.
            if (BulwarkShardCount > 0)
            {
                // Apply the fixed damage reduction from a single shard.  Note: do not reference 'st' here,
                // as this method has access to the fields of the current RogueStats directly.  See ZDoom
                // damage hooks documentation for scope details.
                int beforeBulwark = nd;
                nd = int(ceil(double(nd) * (1.0 - DR_BULWARK_SHARD_DR)));
                BulwarkShardCount--;
                // Log consumption at debug level 1 and above
                CVar cB = CVar.GetCVar("dr_dbg_hits");
                if (cB && cB.GetInt() != 0)
                {
                    Console.Printf(String.Format("[DR BULWARK] Shard consumed: -30%% -> Took %d (was %d) [Shards %d/%d]", nd, beforeBulwark, BulwarkShardCount, BulwarkShardMax));
                }
                if (nd < 0) nd = 0;
            }

            // Apply stage-based scaling if the source is a monster.  Use DR_GetHPScale() from RogueCoreHandler
            if (source != null && source.bIsMonster)
            {
                double sc = RogueCoreHandler.DR_GetHPScale();
                if (sc > 1.0)
                {
                    nd = int(ceil(double(nd) * sc));
                }
            }
            newdamage = nd;
            // Debug log for incoming damage and stage scale.  Include monster class,
            // player HP and armor to aid balancing.  Log only when dr_dbg_hits is nonzero.
            CVar cHitsIn = CVar.GetCVar("dr_dbg_hits");
            if (cHitsIn && cHitsIn.GetInt() != 0)
            {
                double sc_dbg = 1.0;
                String mcls = "";
                if (source != null && source.bIsMonster)
                {
                    sc_dbg = RogueCoreHandler.DR_GetHPScale();
                    mcls = source.GetClassName();
                }
                int hp = pp.health;
                int armor = 0;
                BasicArmor ba = BasicArmor(pp.FindInventory('BasicArmor'));
                if (ba != null) armor = ba.Amount;
                Console.Printf(String.Format("[DR HIT IN] %s inflicted %d (base %d) | HP=%d Arm=%d | DR %.1f%% Stage %.2fx",
                    (mcls.Length() > 0 ? mcls : "Unknown"), newdamage, damage, hp, armor, dr_total*100.0, sc_dbg));
            }
        }
    }
}

class RogueDamage {
    static double MultForLevel(int lvl) {
        if (lvl <= 0) return 1.0;
        // Exponential growth: (1 + DR_DMG_PER_LVL)^lvl with soft/hard caps applied
        double raw = 1.0;
        double step = 1.0 + DR_DMG_PER_LVL;
        // fast pow for small integer lvl to avoid lib calls
        for (int i = 0; i < lvl; i++) raw *= step;
        if (raw > DR_DMG_SOFTCAP) raw = DR_DMG_SOFTCAP + (raw - DR_DMG_SOFTCAP) * DR_DMG_TAPER;
        if (raw > DR_DMG_HARDCAP) raw = DR_DMG_HARDCAP;
        return raw;
    }
}


class RogueXP
{
    static double WeaponWeight(int widx)
    {
        switch (widx) {
            case RW_Shotgun:        return 1.20;
            case RW_SuperShotgun:   return 1.40;
            case RW_Chaingun:       return 1.30;
            case RW_RocketLauncher: return 1.60;
            case RW_PlasmaRifle:    return 1.70;
            case RW_BFG9000:        return 2.00;
            default:                return 1.00;
        }
    }
// === DR NOTE [0.5.259] â 2025-09-02 19:52:47 EDT â Section: Progression â RequiredForNext() ===
// === DR CHECKLIST [0.5.260] â 2025-09-02 19:55:49 EDT â RequiredForNext() ===
// [x] CODE: Growth curve stable; thresholds monotonic
// [ ] USER: Late levels (6â8) not too fast; consider soft-knee if needed
// Confidence: 99.0000% | Completion: 94%
// Future attacks:
//  â¢ Consider soft-knee growth after level 6 to slow late snowballing
//  â¢ Add CVAR gate to scale curve by Â±10% for playtest nights
// Bookmarks: [DR_NOTE_ProgressionRequiredForNext]
    static int RequiredForNext(int lvl, int widx)
    {
        if (lvl < 0) lvl = 0;
        double need = double(XP_BASE_PER_LEVEL) * WeaponWeight(widx);
        for (int i = 0; i < lvl; i++) need *= XP_GROWTH_FACTOR;
        int req = int(need + 0.5);
        if (req < 1) req = 1;
        return req;
    }
}

enum DRBoonId
{
    DRB_None, DRB_BlueVialMastery, DRB_ArmorBonusMastery, DRB_MarineGrit, DRB_DamageBooster,
    DRB_Legacy_WeaponXP1, DRB_StimpackTraining, DRB_MedikitTraining, DRB_ArmorReinfI, DRB_ArmorReinfII,
    DRB_DeimosBulwark, DRB_AdrenalSurge, DRB_UACCombatDrills, DRB_Legacy_WeaponXP2, DRB_AegisFrame,
    DRB_UACOvercharger, DRB_SoulSiphon, DRB_SecurityArmorMk2, DRB_CombatArmorMk3, DRB_UACXPSurge,
    DRB_SuperchargeBooster, DRB_BerserkRite, DRB_QuadDamage, DRB_MTYB,
    // New boons added in beta 18
    DRB_Executioner, DRB_BulwarkShards, DRB_StageTamer, DRB_HeavySlayer, DRB_CrowdFrenzy,
    // New boons introduced in beta 22
    DRB_RaiseMaxHealth, DRB_RaiseMaxArmor, DRB_MaxHealthDamage, DRB_BerserkingFirepower, DRB_TimeRewind,
    // New boon (beta 26): Minor Raise Max Health – grants a small (5 HP) increase to max health.
    DRB_RaiseMaxHealthMinor
}

class RogueBoons
{
    // Console log line for boon gains.  In beta 27 the message format has
    // been simplified to remove the "Boon Gained" prefix and avoid
    // repeating the description in the console.  The boon name and
    // description are separated by a newline for readability.
    play static void ConsoleBoon(PlayerPawn pp, DRBoonId id)
    {
        if (pp == null) return;
        String name = BoonName(id);
        String desc = BoonDesc(id);
        Console.Printf("%s:\n%s", name, desc);
    }

    // Humanâreadable display name for a given boon.  ZScript does not infer
    // names from the enumeration values, so explicitly map each DRBoonId to
    // a concise title.  If a new boon is added to the enum and not handled
    // here the default branch will return "Unknown Boon".
    static String BoonName(DRBoonId id)
    {
        switch (id)
        {
            case DRB_None:               return "None";
            case DRB_BlueVialMastery:    return "Blue Vial Mastery";
            case DRB_ArmorBonusMastery:  return "Armor Bonus Mastery";
            case DRB_MarineGrit:         return "Marine Grit";
            case DRB_DamageBooster:      return "Damage Booster";
            case DRB_Legacy_WeaponXP1:   return "Legacy Weapon XP I";
            case DRB_StimpackTraining:   return "Stimpack Training";
            case DRB_MedikitTraining:    return "Medikit Training";
            case DRB_ArmorReinfI:        return "Armor Reinforcement I";
            case DRB_ArmorReinfII:       return "Armor Reinforcement II";
            case DRB_DeimosBulwark:      return "Deimos Bulwark";
            case DRB_AdrenalSurge:       return "Adrenal Surge";
            case DRB_UACCombatDrills:    return "UAC Combat Drills";
            case DRB_Legacy_WeaponXP2:   return "Legacy Weapon XP II";
            case DRB_AegisFrame:         return "Aegis Frame";
            case DRB_UACOvercharger:     return "UAC Overcharger";
            case DRB_SoulSiphon:         return "Soul Siphon";
            case DRB_SecurityArmorMk2:   return "Security Armor Mk2";
            case DRB_CombatArmorMk3:     return "Combat Armor Mk3";
            case DRB_UACXPSurge:         return "UAC XP Surge";
            case DRB_SuperchargeBooster: return "Supercharge Booster";
            case DRB_BerserkRite:        return "Berserk Rite";
            case DRB_QuadDamage:         return "Quad Damage";
            case DRB_MTYB:               return "MTYB";
            // New boons introduced in beta 18
            case DRB_Executioner:        return "Executioner";
            case DRB_BulwarkShards:      return "Bulwark";
            case DRB_StageTamer:         return "Stage Tamer";
            case DRB_HeavySlayer:        return "Heavy Slayer";
            case DRB_CrowdFrenzy:        return "Crowd Frenzy";
            // New boons (beta 22)
            case DRB_RaiseMaxHealth:      return "Raise Max Health";
            case DRB_RaiseMaxArmor:       return "Raise Max Armor";
            case DRB_MaxHealthDamage:     return "Max Health Damage";
            case DRB_BerserkingFirepower:return "Berserking Firepower";
            case DRB_TimeRewind:         return "Time Rewind";
            case DRB_RaiseMaxHealthMinor: return "Minor Raise Max Health";
            default:                     return "Unknown Boon";
        }
    }

    // Determine a colour code for HUD toast messages based on the boon type.
    // These codes use ZDoom message colours: \cg = green, \cj = blue, \cr = red,
    // \co = orange.  Healing and defensive boons are green, XP and utility
    // boons are blue, legendary or mythic boons (Quad Damage, Berserk Rite,
    // Nightmare Protocol, MTYB) are red, and all remaining stat boosters and
    // offensive boons default to orange.  If you add a new boon to the
    // enumeration be sure to map it here to an appropriate colour.
    static String BoonColor(DRBoonId id)
    {
        // Assign a HUD colour based on the perceived rarity of the boon.
        // Rarity mapping:
        //  • Common (white): baseline stat boosters and training (Damage Booster,
        //    Supercharge Booster, Marine Grit, Blue Vial/Armor Bonus mastery,
        //    Stimpack/Medikit training, Armor reinforcements, Legacy Weapon XP
        //    tiers, Aegis Frame).
        //  • Uncommon (green): utility/defence items that enhance general
        //    performance (Combat Drills, UAC Overcharger, Deimos Bulwark).
        //  • Higher‑uncommon (blue): timed utility or healing boons (UAC XP Surge,
        //    Adrenal Surge, Soul Siphon).
        //  • Rare (purple): powerful but not game‑breaking effects (Nightmare
        //    Protocol, Berserk Rite).
        //  • Legendary (orange): exceptionally strong power‑ups (Quad Damage).
        //  • Mythic (red): ultra‑rare, run‑changing boons (MTYB).
        switch (id)
        {
            // Common boons: baseline stat boosters and training
            case DRB_BlueVialMastery:
            case DRB_ArmorBonusMastery:
            case DRB_StimpackTraining:
            case DRB_MedikitTraining:
            case DRB_ArmorReinfI:
            case DRB_ArmorReinfII:
            case DRB_AegisFrame:
            case DRB_Legacy_WeaponXP1:
            case DRB_Legacy_WeaponXP2:
                return "\\cF"; // white

            // Uncommon boons: core offensive and utility boosts
            case DRB_DamageBooster:
            case DRB_SuperchargeBooster:
            case DRB_UACCombatDrills:
            case DRB_UACOvercharger:
            case DRB_MarineGrit:
                return "\\cA"; // green (bright)

            // Higher‑uncommon boons: timed XP or healing effects
            case DRB_UACXPSurge:
            case DRB_AdrenalSurge:
            case DRB_SoulSiphon:
                return "\\c9"; // blue

            // Rare boons: powerful defensive or special effects
            case DRB_DeimosBulwark:
            case DRB_BerserkRite:
                return "\\cD"; // purple (magenta)

            // Legendary boons: exceptional damage power‑ups
            case DRB_QuadDamage:
                return "\\cE"; // yellow/orange

            // Mythic boons: ultra‑rare, run‑changing effects
            case DRB_MTYB:
                return "\\cC"; // red

            // New boons: assign colours by rarity
            case DRB_Executioner:
            case DRB_BulwarkShards:
                // Uncommon green for mid-tier defensive/offensive boons
                return "\\cA";
            case DRB_StageTamer:
            case DRB_HeavySlayer:
            case DRB_CrowdFrenzy:
                // Rare boons use purple for strong special effects
                return "\\cD";

            // Raise max HP/Armor and minor HP raises are rare utility boons: purple
            case DRB_RaiseMaxHealth:
            case DRB_RaiseMaxArmor:
            case DRB_RaiseMaxHealthMinor:
            case DRB_TimeRewind:
                return "\\cD";
            // Max Health Damage and Berserking Firepower are legendary offensive boons: orange
            case DRB_MaxHealthDamage:
            case DRB_BerserkingFirepower:
                return "\\cE";

            // Fallback to default
            default:
                return "\\cF";
        }
    }

    // Choose an appropriate font name for the given boon rarity.  Rare,
    // legendary and mythic boons use the larger BigFont to emphasise their
    // importance.  Common and uncommon boons leave the font parameter empty,
    // causing A_PrintBold to fall back to SmallFont (the default)【982810389894626†L7-L18】.
    static String BoonFont(DRBoonId id)
    {
        switch (id)
        {
            case DRB_BerserkRite:
            case DRB_QuadDamage:
            case DRB_MTYB:
                return "BigFont";
            // New legendary boons use BigFont for emphasis
            case DRB_MaxHealthDamage:
            case DRB_BerserkingFirepower:
            case DRB_TimeRewind:
                return "BigFont";
            default:
                return "";
        }
    }

    // Print a boon acquisition message with an extra descriptor.  This helper
    // wraps ConsoleBoon() and appends the effect description on the same line
    // for brevity.  If pp is null the call is ignored.
    play static void PrintBoonConsole(PlayerPawn pp, DRBoonId id, String extra)
    {
        if (pp == null) return;
        // Build the base message manually to avoid String.Format() argument mismatches.  Use the .. operator for concatenation,
        // as recommended by the ZDoom Wiki【960410346502109†L93-L101】.
        // Compose a simplified base message consisting of the boon name on the first
        // line and its description on the next.  The "Boon Gained" prefix has
        // been removed for brevity.  A newline separates name and description.
        String baseMsg = BoonName(id) .. ":\n" .. BoonDesc(id);
        // Append any extra descriptor in parentheses after the description.
        bool hasExtra = (extra.Length() > 0);
        String fullMsg = hasExtra ? (baseMsg .. " (" .. extra .. ")") : baseMsg;
        // Use a format string when printing to the console.  Without the "%s" specifier
        // percent signs in the message are treated as placeholders and cause a crash if
        // there are no numeric arguments.  Passing the format explicitly ensures
        // percent signs in boon descriptions (e.g., “+15% XP”) are printed literally.
        Console.Printf("%s", fullMsg);
        // Determine a colour prefix based on the boon ID.  Append \c- at the end
        // to reset the colour after printing.  The HUD toast will therefore use
        // green for healing boons, blue for utility, red for legendary/mythic and
        // orange for offensive upgrades.
        String colour = BoonColor(id);
        String hudMsg = colour .. fullMsg .. "\\c-";
        String fontName = BoonFont(id);
        // Display the colourised message on the HUD via both A_Log and A_PrintBold.  Use
        // BigFont for rare/legendary/mythic boons.  When no custom font is supplied
        // A_PrintBold will fall back to SmallFont【982810389894626†L7-L18】.
        pp.A_Log(hudMsg);
        if (fontName.Length() > 0)
        {
            pp.A_PrintBold(hudMsg, 0.0, fontName);
        }
        else
        {
            pp.A_PrintBold(hudMsg);
        }
    }

    // Select a boon when the player activates a cheat tier.  For now this
    // delegates to the standard SelectBoon() logic for normal tiers and
    // chooses a legendary boon for the highest tier.  This can be tuned
    // later to incorporate custom cheatâtier weighting.
    static DRBoonId PickCheatFromTier(RogueStats st, int widx, int tier)
    {
        // Tier 5: mythic/legendary override
        if (tier >= 5) return PickLegendary();
        // For lower tiers simply call the weighted selector; use the playerâs
        // current level for context if available but it is not strictly needed.
        int lvl = 0;
        if (st != null && widx >= 0 && widx < RW_Count) lvl = st.Level[widx];
        return SelectBoon(st, widx, lvl);
    }

    // Short description for each boon id used in toasts
    static String BoonDesc(DRBoonId id)
    {
        // Returns a short description used for HUD toasts. This switch covers the core boon IDs.
        switch (id)
        {
            // Core offensive and utility boons
            case DRB_DamageBooster:       return "Increases this weapon's damage.";
            case DRB_SuperchargeBooster:  return "Extends your Supercharge buff.";
            case DRB_UACCombatDrills:     return "+15% global XP gain.";
            case DRB_UACOvercharger:      return "+15% damage with the current weapon.";
            case DRB_MTYB:                return "MAKE THEM YOUR BITCH.";

            // Defensive and healing boons
            case DRB_DeimosBulwark:       return "Adds a Bulwark DR stack.";
            case DRB_MarineGrit:          return "Adds a DR stack.";
            case DRB_AdrenalSurge:        return "Temporary damage‑reduction shield (8 s).";
            case DRB_SoulSiphon:          return "Heals per kill (10 s).";
            case DRB_UACXPSurge:          return "+50% XP (10 s).";
            case DRB_BerserkRite:         return "Adds a Steadfast DR stack.";
            case DRB_QuadDamage:          return "Quad damage (15 s).";

            // Beta 18/22 special boons
            case DRB_Executioner:         return "Deals extra damage to low‑health enemies.";
            case DRB_BulwarkShards:       return "Grants Bulwark shards for damage reduction.";
            case DRB_StageTamer:          return "Slows stage difficulty scaling.";
            case DRB_HeavySlayer:         return "Deals extra damage to heavy enemies.";
            case DRB_CrowdFrenzy:         return "Chain kills to build a damage buff.";
            case DRB_RaiseMaxHealth:      return "+25 max HP.";
            case DRB_RaiseMaxArmor:       return "+25 max armor.";
            case DRB_RaiseMaxHealthMinor: return "+5 max HP.";
            case DRB_MaxHealthDamage:     return "Damage bonus at max HP.";
            case DRB_BerserkingFirepower: return "+15% global damage.";
            case DRB_TimeRewind:          return "Allows rewinding time once per run.";
            default:                      return "Power up";
        }
    }

    play static void HealCapped(PlayerPawn pp, int amount, bool allow200)
    {
        if (!pp || amount <= 0) return;
        // Always compute a dynamic maximum to allow overheal beyond 100 HP.
        // Base cap is DR_MAX_HEALTH_CAP; each Raise Max Health boon adds
        // DR_RAISE_HEALTH_INC and each Minor Raise Max Health adds
        // DR_RAISE_HEALTH_MINI_INC.  Clamp to DR_RAISE_HEALTH_CAP.
        RogueStats st = RogueCoreHandler.GetOrGiveStats(pp);
        int cap = DR_MAX_HEALTH_CAP;
        if (st != null)
        {
            cap = DR_MAX_HEALTH_CAP
                + st.MaxHealthBonus * DR_RAISE_HEALTH_INC
                + st.MinorHealthBonus * DR_RAISE_HEALTH_MINI_INC;
            if (cap > DR_RAISE_HEALTH_CAP) cap = DR_RAISE_HEALTH_CAP;
        }
        // For PlayerPawn, the second argument to GiveBody() defines the
        // absolute maximum health to heal up to.  If bonushealth (from
        // items like MaxHealth) is modified this value is added
        // automatically.  Passing cap directly allows healing up to the
        // computed cap.  See ZDoom Wiki—GiveBody notes【763811613711043†L37-L49】.
        int maxheal = cap;
        if (!allow200 && maxheal > 100) maxheal = 100;
        pp.GiveBody(amount, maxheal);
        // After healing, clamp to the cap explicitly in case GiveBody
        // overshoots when bonushealth is present.
        if (pp.health > cap) pp.health = cap;
    }

    play static int ArmorGrantScaled(PlayerPawn pp, int baseAmount, RogueStats st)
    {
        if (!pp || baseAmount <= 0) return 0;
        double mul = 1.0;
        if (st)
        {
            mul = DRPatchHelpers.Powd(1.15, st.Boon_ArmorReinfI) * DRPatchHelpers.Powd(1.25, st.Boon_ArmorReinfII);
        }
        int amt = int(int(baseAmount) * mul + 0.5);
        if (amt < 1) amt = 1;

        pp.A_GiveInventory("ArmorBonus", amt);

        let ba = BasicArmor(pp.FindInventory('BasicArmor'));
        if (ba)
        {
            // Compute dynamic armour cap: base 200 plus Raise Max Armour tiers.
            int cap = DR_MAX_ARMOR_CAP + ((st != null) ? st.MaxArmorBonus * DR_RAISE_ARMOR_INC : 0);
            if (cap > DR_RAISE_ARMOR_CAP) cap = DR_RAISE_ARMOR_CAP;
            // Update the BasicArmor's MaxAmount so that future armour pickups can exceed 200.
            ba.MaxAmount = cap;
            // Clamp current armour to the cap.
            if (ba.Amount > cap) ba.Amount = cap;
        }
        return amt;
    }

    static double OverMultFor(RogueStats st, int widx)
    {
        if (!st || widx < 0 || widx >= RW_Count) return 1.0;
        double m = (st) ? st.OverMult[widx] : 1.0;
        // Cap the multiplier to the configured maximum to prevent runaway damage scaling.
        if (m > DR_OVERMULT_CAP) m = DR_OVERMULT_CAP;
        return (m <= 0.0) ? 1.0 : m;
    }

    static double DR_Total(RogueStats st)
    {
        if (!st) return 0.0;

        double bul = 0.0;
        if (st.Boon_BulwarkStacks >= 3) bul = DR_BULWARK_S1 + DR_BULWARK_S2 + DR_BULWARK_S3;
        else if (st.Boon_BulwarkStacks == 2) bul = DR_BULWARK_S1 + DR_BULWARK_S2;
        else if (st.Boon_BulwarkStacks == 1) bul = DR_BULWARK_S1;

        double proj = st.Boon_SteadfastStacks * DR_STEADFAST_PERSTACK + bul;
        double temp = (st.AdrenalShieldTics > 0) ? DR_ADRENAL_DR : 0.0;
        double tot = proj + temp;

        if (tot > DR_DR_CAP) tot = DR_DR_CAP;
        if (tot < 0.0) tot = 0.0;
        return tot;
    }
    ui static double DR_Total_UI(RogueStats st) { return DR_Total(st); }

    static DRBoonId PickLegendary()
    {
        DRBoonId live[2]; int n = 0;
        live[n++] = DRB_BerserkRite;
        live[n++] = DRB_QuadDamage;
        return live[Random(0, n-1)];
    }

// === DR NOTE [0.5.259] â 2025-09-02 19:52:47 EDT â Section: Boons â SelectBoon() weights + pity ===
// === DR CHECKLIST [0.5.260] â 2025-09-02 19:55:49 EDT â SelectBoon() Weights + Pity ===
// [x] CODE: Weights Offense/Defense/Utility = 60/25/15
// [x] CODE: Defense pity after 3 misses
// [x] CODE: XP boons gated by GlobalXPMult < 3.0
// [ ] USER: Defense appears at reasonable cadence (pity feels natural)
// Confidence: 99.0000% | Completion: 95%
// Future attacks:
//  â¢ Observe Defense appearance rate across maps; adjust 60/25/15 if needed
//  â¢ When GlobalXPMult â¥ 2.5, skew stronger toward Soul Siphon (monitor)
// Bookmarks: [DR_NOTE_BoonsSelectBoonweightspity]
    static DRBoonId SelectBoon(RogueStats st, int widx, int newLevel)
    {
        // Core 8 selection with weights and pity
        // Mythic override (very rare)
        int r = Random(0,99);
        if (st && st.MythicCD <= 0)
        {
            int myth = Random(0,999); // 0.1% chance
            if (myth == 0) return DRB_MTYB;
        }

        // Pity: force Defense if we've gone too long without it
        // Choose category purely by weighted random chance.  The previous
        // implementation included a defense pity mechanic that incremented
        // counters stored on RogueStats; however assigning to those fields
        // caused compilation errors on some engine versions.  To preserve
        // gameplay balance while avoiding modifiability issues, the pity
        // mechanism has been temporarily removed.  Offense has 60% weight,
        // Defense 25%, Utility 15%.
        int category = 0;
        {
            int w = Random(1,100);
            if (w <= 60) category = DR_CAT_OFFENSE;
            else if (w <= 85) category = DR_CAT_DEFENSE;
            else category = DR_CAT_UTILITY;
        }

        // Choose within category
        switch (category)
        {
            case DR_CAT_OFFENSE:
            {
                // Weighted selection for offensive boons.  Damage Booster and Overcharger remain common,
                // Executioner and Heavy Slayer are mid‑tier, Quad Damage and Berserking Firepower are
                // rare.  Probabilities: 30% Damage Booster, 20% UAC Overcharger, 15% Executioner,
                // 15% Heavy Slayer, 10% Berserking Firepower, 10% Quad Damage.
                int pick = Random(1,100);
                if (pick <= 30) return DRB_DamageBooster;
                else if (pick <= 50) return DRB_UACOvercharger;
                else if (pick <= 65) return DRB_Executioner;
                else if (pick <= 80) return DRB_HeavySlayer;
                else if (pick <= 90) return DRB_BerserkingFirepower;
                else return DRB_QuadDamage;
            }

            case DR_CAT_DEFENSE:
            {
                // Defensive boons: Marine Grit, Bulwark Shards, Adrenal Surge, Deimos Bulwark,
                // and Armor Bonus Mastery.  Probabilities: 40% Marine Grit, 20% Bulwark Shards,
                // 15% Adrenal Surge, 15% Deimos Bulwark, 10% Armor Bonus Mastery.
                int pick = Random(1,100);
                if (pick <= 40) return DRB_MarineGrit;
                else if (pick <= 60) return DRB_BulwarkShards;
                else if (pick <= 75) return DRB_AdrenalSurge;
                else if (pick <= 90) return DRB_DeimosBulwark;
                else return DRB_ArmorBonusMastery;
            }

            default: // DR_CAT_UTILITY
            {
                // Utility boons: XP Surge, Soul Siphon, Stage Tamer, Raise Max HP/Armor and Time Rewind.
                // If XP multiplier is already high, emphasise healing and pacing; otherwise prioritise XP surge.
                bool xpHigh = (st && st.GlobalXPMult >= 2.5);
                int pick = Random(1,100);
                if (xpHigh)
                {
                    // With high XP, emphasise healing and pacing.  Allocate a small chance to the
                    // Minor Raise Max Health boon so that +5 HP increases remain rare.  The
                    // probabilities sum to 100.
                    if (pick <= 33) return DRB_SoulSiphon;
                    else if (pick <= 58) return DRB_StageTamer;
                    else if (pick <= 73) return DRB_RaiseMaxHealth;
                    else if (pick <= 83) return DRB_RaiseMaxArmor;
                    else if (pick <= 88) return DRB_RaiseMaxHealthMinor;
                    else return DRB_UACXPSurge;
                }
                else
                {
                    // Normal XP: prioritise XP Surge, then healing and pacing.  Include Minor
                    // Raise Max Health as a very rare option.  The probabilities sum to 100.
                    if (pick <= 40) return DRB_UACXPSurge;
                    else if (pick <= 65) return DRB_SoulSiphon;
                    else if (pick <= 85) return DRB_StageTamer;
                    else if (pick <= 91) return DRB_RaiseMaxHealth;
                    else if (pick <= 96) return DRB_RaiseMaxArmor;
                    else if (pick <= 98) return DRB_RaiseMaxHealthMinor;
                    else return DRB_TimeRewind;
                }
            }
        }
        return DRB_DamageBooster; // safety
    }

// === DR NOTE [0.5.259] â 2025-09-02 19:52:47 EDT â Section: Boons â ApplyBoon() Core 8 + aliases ===
// === DR CHECKLIST [0.5.260] â 2025-09-02 19:55:49 EDT â ApplyBoon() Core 8 + Aliases ===
// [x] CODE: Core 8 implemented; legacy IDs mapped
// [x] CODE: DamageBooster +3% per-weapon; clamp cap 1.50Ã
// [x] CODE: Overcharger +15% per-weapon; clamp cap 1.50Ã
// [ ] REVIEW: Soul Siphon per-map heal cap verified in code path
// [ ] USER: Boon name/details always printed in console
// Confidence: 99.1000% | Completion: 96%
// Future attacks:
//  â¢ Audit DR caps once more after more playtime (OverMult cap 1.50)
//  â¢ Tiny pity tuning: 2â3 window vs. 3; keep logs
//  â¢ Add CVAR to disable mythical MTYB for competitive runs
// Bookmarks: [DR_NOTE_BoonsApplyBoonCore8aliases]
    // Retain the original boon logic under a legacy name. Calls to ApplyBoon() will refer to the new version below.
    play static void ApplyBoon_Old(PlayerPawn pp, RogueStats st, int widx, int newLevel, DRBoonId id)
    {
        // Legacy implementation disabled. Immediately return and comment out the rest of this function.
        return;
        /*
        int _w = (widx >= 0 && widx < RW_Count) ? widx : -1;

        if (level.NetMode == NM_Client) return; // DR: server-authoritative mutation guard

        switch (id)
        {


case DRB_DamageBooster:
                break;
                if (widx>=0 && widx<RW_Count){ if (st.OverMult[widx]<=0) st.if (_w>=0) OverMult[_w] =1.0;
                RogueBoons.PrintBoonConsole(pp, DRB_DamageBooster, "+3% this weapon"); st.if (_w>=0) OverMult[_w] *=1.03;                     if (st.OverMult[widx] > DR_OVERMULT_CAP) st.if (_w>=0) OverMult[_w] = DR_OVERMULT_CAP;
}







case DRB_UACCombatDrills:
                break;
                if (st.AccelStacks<DR_XP_GLOBAL_MAXSTK){
                    st.AccelStacks++; st.GlobalXPMult*=DR_XP_GLOBAL_STEP; if (st.GlobalXPMult>3.0) st.GlobalXPMult=3.0;
                RogueBoons.PrintBoonConsole(pp, DRB_UACCombatDrills, "");
                }


case DRB_UACOvercharger:
                break;
                if (widx>=0&&widx<RW_Count){
                    if (st.OverMult[widx]<=0) st.if (_w>=0) OverMult[_w] =1.15;
                RogueBoons.PrintBoonConsole(pp, DRB_UACOvercharger, "");
                    if (st.OverMult[widx] > DR_OVERMULT_CAP) st.if (_w>=0) OverMult[_w] = DR_OVERMULT_CAP;
                    st.if (_w>=0) OverMult[_w] *=DR_OC_BONUS_MULT; st.OverLastLvl[widx]=newLevel; st.OverCoilCount[widx]++;
                }




case DRB_SuperchargeBooster:
                break;
                if (st.SuperchargeStacks<DR_SCBOOST_MAX) st.SuperchargeStacks++;



case DRB_MTYB:
                break;
                if (pp)
                {
                    pp.A_GiveInventory("Megasphere",1);
                    let clip=Ammo(pp.FindInventory('Clip'));        if (clip)   clip.Amount=clip.MaxAmount;
                    let shell=Ammo(pp.FindInventory('Shell'));      if (shell)  shell.Amount=shell.MaxAmount;
                    let rocket=Ammo(pp.FindInventory('RocketAmmo'));if (rocket) rocket.Amount=rocket.MaxAmount;
                    let cell=Ammo(pp.FindInventory('Cell'));        if (cell)   cell.Amount=cell.MaxAmount;
                    CVar inv=CVar.GetCVar("dr_leg_invul"); if (inv && inv.GetInt()!=0) pp.A_GiveInventory("DR_Invul_Legend",1);
                }
                st.GlobalXPMult*=DR_XP_GLOBAL_MTYB; if (st.GlobalXPMult>3.0) st.GlobalXPMult=3.0;
                st.QuadTics=int(DR_QD_SECONDS*TICRATE+0.5); st.MythicCD=8;
}
    
        // Fallback toast if specific case didn't push one
        // (toast removed: console-only)
ConsoleBoon(pp, id);


// (legacy note collapsed into DR NOTE; see ApplyBoon section)
case DRB_BlueVialMastery:
                if (st.Boon_SteadfastStacks<5) st.Boon_SteadfastStacks++;
                break;

case DRB_ArmorBonusMastery:
                if (st.Boon_SteadfastStacks<5) st.Boon_SteadfastStacks++;
                break;

case DRB_MarineGrit:
                if (st.Boon_SteadfastStacks<10) st.Boon_SteadfastStacks++;
                RogueBoons.PrintBoonConsole(pp, DRB_MarineGrit, "+2% DR stack");
                break;

case DRB_Legacy_WeaponXP1:
                st.GlobalXPMult *= 1.05;
                if (st.GlobalXPMult > 3.0) st.GlobalXPMult = 3.0;
                break;

case DRB_StimpackTraining:
                if (st.StimTier<2) st.StimTier++;
                break;

case DRB_MedikitTraining:
                if (st.MedikitTier<2) st.MedikitTier++;
                break;

case DRB_ArmorReinfI:
                if (st.Boon_SteadfastStacks<5) st.Boon_SteadfastStacks++;
                break;

case DRB_ArmorReinfII:
                if (st.Boon_SteadfastStacks<5) st.Boon_SteadfastStacks++;
                break;

case DRB_DeimosBulwark:
                if (st.Boon_SteadfastStacks<5) st.Boon_SteadfastStacks++;
                break;

case DRB_AdrenalSurge:
                st.Boon_AdrenalShield = 1;
                st.AdrenalShieldTics += 35*8;
                RogueBoons.PrintBoonConsole(pp, DRB_AdrenalSurge, "Shield");
                break;

case DRB_Legacy_WeaponXP2:
                st.GlobalXPMult *= 1.10;
                if (st.GlobalXPMult > 3.0) st.GlobalXPMult = 3.0;
                break;

case DRB_AegisFrame:
                st.Boon_AdrenalShield = 1; st.AdrenalShieldTics += 35*8;
                break;

case DRB_SoulSiphon:
                // Grant or upgrade the Soul Siphon boon.  Each pickup
                // increments the heal amount up to DR_SS_MAX_RANK and resets
                // the duration to DR_SS_BASE_DURATION seconds.  Overheal is
                // permitted up to 200 HP.  Notify via coloured toast.
                st.Boon_SoulSiphon = 1;
                if (st.SoulSiphonLevel < DR_SS_MAX_RANK) st.SoulSiphonLevel++;
                st.SoulSiphonTics = int(DR_SS_BASE_DURATION * TICRATE + 0.5);
                st.SoulSiphonNotified = false;
                // Describe the effect with the current level and duration.
                // Describe the heal per kill without repeating the duration.  The duration
                // is conveyed by the boon description.  Only include the HP per kill
                // value as the extra string.
                String desc = String.Format("+%d HP/kill", st.SoulSiphonLevel);
                RogueBoons.PrintBoonConsole(pp, DRB_SoulSiphon, desc);
                // Immediately inform the player that Soul Siphon is active along with
                // the remaining duration.  This supplements the mid‑screen toast and
                // ensures visibility even if debug logs are off.
                int ss_rem = int(DR_SS_BASE_DURATION);
                Console.Printf(String.Format("[DR SS] Soul Siphon active (%d s remaining)", ss_rem));
                break;

case DRB_SecurityArmorMk2:
                if (st.Boon_SteadfastStacks<5) st.Boon_SteadfastStacks++;
                break;

case DRB_CombatArmorMk3:
                if (st.Boon_SteadfastStacks<5) st.Boon_SteadfastStacks++;
                break;

case DRB_UACXPSurge:
                if (st.TimedXPMult < 1.5) st.TimedXPMult = 1.5;
                if (st.TimedXPTics < 35*10) st.TimedXPTics = 35*10;
                // Avoid duplicating the magnitude and duration in the extra string.  The
                // description already states "+50% XP" and indicates the duration.
                RogueBoons.PrintBoonConsole(pp, DRB_UACXPSurge, "");
                break;

case DRB_NightmareProtocol:
                if (st.AccelStacks<5) st.AccelStacks++;
                break;

case DRB_BerserkRite:
                if (st.Boon_SteadfastStacks<10) st.Boon_SteadfastStacks++;
                break;

case DRB_QuadDamage:
                st.QuadTics += 35*4;
                RogueBoons.PrintBoonConsole(pp, DRB_QuadDamage, "");
                break;
        */
}

    play static void OnLevelUp(PlayerPawn pp, RogueStats st, int widx, int newLevel)
    {
        if (!pp || !st) return;
        if (st.Boon_AegisFrame) pp.A_GiveInventory("DR_Invul_Short", 1);
        if (st.Boon_AdrenalShield) st.AdrenalShieldTics = int(DR_ADRENAL_SECONDS * TICRATE + 0.5);
        DRBoonId pick = SelectBoon(st, widx, newLevel);
        ApplyBoon(pp, st, widx, newLevel, pick);
    }

    // This is a cleaned and modern implementation of ApplyBoon.  It replaces the broken legacy
    // logic with a structured switch that applies each boonâs effect and logs a descriptive
    // message to the console.  It is defined after OnLevelUp so it supersedes the legacy
    // ApplyBoon_Old function.  OnLevelUp and other callers now invoke this version.
    play static void ApplyBoon(PlayerPawn pp, RogueStats st, int widx, int newLevel, DRBoonId id)
    {
        int _w = (widx >= 0 && widx < RW_Count) ? widx : -1;

        // Only run mutations in singleâplayer or when executed on the server.  The
        // original code referenced level.NetMode and NM_Client, but those values
        // are not available in this version of GZDoom.  Omitting this guard
        // avoids compile errors and allows the boon to apply locally.  For
        // multiplayer scenarios a more robust netmode check could be added.
        // (Removed NetMode guard.)

        bool printed = false;

        switch (id)
        {
            case DRB_DamageBooster:
            {
                if (_w >= 0)
                {
                    if (st.OverMult[_w] <= 0) st.OverMult[_w] = 1.0;
                    st.OverMult[_w] *= 1.03;
                    if (st.OverMult[_w] > DR_OVERMULT_CAP) st.OverMult[_w] = DR_OVERMULT_CAP;
                }
                RogueBoons.PrintBoonConsole(pp, DRB_DamageBooster, "+3% this weapon");
                printed = true;
                break;
            }
            case DRB_UACCombatDrills:
            {
                if (st.AccelStacks < DR_XP_GLOBAL_MAXSTK)
                {
                    st.AccelStacks++;
                    st.GlobalXPMult *= DR_XP_GLOBAL_STEP;
                    if (st.GlobalXPMult > 3.0) st.GlobalXPMult = 3.0;
                }
RogueBoons.PrintBoonConsole(pp, DRB_UACCombatDrills, "");
                printed = true;
                break;
            }
            case DRB_UACOvercharger:
            {
                if (_w >= 0)
                {
                    if (st.OverMult[_w] <= 0) st.OverMult[_w] = 1.15;
                    st.OverMult[_w] *= DR_OC_BONUS_MULT;
                    if (st.OverMult[_w] > DR_OVERMULT_CAP) st.OverMult[_w] = DR_OVERMULT_CAP;
                    st.OverLastLvl[_w] = newLevel;
                    st.OverCoilCount[_w]++;
                }
RogueBoons.PrintBoonConsole(pp, DRB_UACOvercharger, "");
                printed = true;
                break;
            }
            case DRB_SuperchargeBooster:
            {
                if (st.SuperchargeStacks < DR_SCBOOST_MAX) st.SuperchargeStacks++;
                RogueBoons.PrintBoonConsole(pp, DRB_SuperchargeBooster, "+1 Supercharge stack");
                printed = true;
                break;
            }
            case DRB_MTYB:
            {
                if (pp != null)
                {
                    pp.A_GiveInventory("Megasphere", 1);
                    let clip  = Ammo(pp.FindInventory('Clip'));
                    if (clip)  clip.Amount  = clip.MaxAmount;
                    let shell = Ammo(pp.FindInventory('Shell'));
                    if (shell) shell.Amount = shell.MaxAmount;
                    let rocket = Ammo(pp.FindInventory('RocketAmmo'));
                    if (rocket) rocket.Amount = rocket.MaxAmount;
                    let cell  = Ammo(pp.FindInventory('Cell'));
                    if (cell) cell.Amount = cell.MaxAmount;
                    CVar inv = CVar.GetCVar("dr_leg_invul");
                    if (inv && inv.GetInt() != 0) pp.A_GiveInventory("DR_Invul_Legend", 1);
                    // Play a Romero head hurt sound when MTYB is granted.  Use a low
                    // pitch for dramatic effect.  The romero_hurt alias is defined
                    // in SNDINFO and maps to dsbossit (Icon of Sin hit sound).  See
                    // A_StartSound documentation for parameter order【902386242468717†L9-L19】.
                    pp.A_StartSound("romero_hurt", CHAN_VOICE, CHANF_DEFAULT, 1.0, ATTN_NONE, 0.5);
                }
                st.GlobalXPMult *= DR_XP_GLOBAL_MTYB;
                if (st.GlobalXPMult > 3.0) st.GlobalXPMult = 3.0;
                // Grant MTYB: full heal & ammo with a longer Quad Damage effect.  The
                // player receives a 30 s Quad Damage instead of the standard
                // DR_QD_SECONDS duration.  Mythic cooldown remains unchanged.
                st.QuadTics = int(30.0 * TICRATE + 0.5);
                st.MythicCD = 8;
                // Print minimal toast for MTYB: omit effect description.  The description
                // itself is provided by BoonDesc() ("MAKE THEM YOUR BITCH.").
                RogueBoons.PrintBoonConsole(pp, DRB_MTYB, "");
                printed = true;
                break;
            }
            case DRB_BlueVialMastery:
            {
                // Increase Blue Vial stack up to the configured maximum.  Each stack
                // adds extra HP when picking up a HealthBonus.  See DR_HealthBonusProxy.
                if (st.BlueVialStacks < DR_BLUEVIAL_MAX) st.BlueVialStacks++;
                RogueBoons.PrintBoonConsole(pp, DRB_BlueVialMastery, "+1 vial heal");
                printed = true;
                break;
            }
            case DRB_ArmorBonusMastery:
            {
                // Increase Armor Bonus stack up to the configured maximum.  Each stack
                // grants additional armor when picking up ArmorBonus items.
                if (st.ArmorBonusStacks < DR_ARMORBONUS_MAX) st.ArmorBonusStacks++;
                RogueBoons.PrintBoonConsole(pp, DRB_ArmorBonusMastery, "+1 armor bonus");
                printed = true;
                break;
            }
            case DRB_MarineGrit:
            {
                // Marine Grit increases the player’s Steadfast stack count.  Each
                // stack now provides 5% DR (see DR_STEADFAST_PERSTACK).  Cap
                // stacks at 6 to slow the accumulation of damage reduction and
                // make it harder to reach the 75% cap early.  Print a concise
                // toast reflecting the new per‑stack value.
                if (st.Boon_SteadfastStacks < 6) st.Boon_SteadfastStacks++;
                RogueBoons.PrintBoonConsole(pp, DRB_MarineGrit, "+5% DR");
                printed = true;
                break;
            }
            case DRB_Legacy_WeaponXP1:
            {
                st.GlobalXPMult *= 1.05;
                if (st.GlobalXPMult > 3.0) st.GlobalXPMult = 3.0;
                RogueBoons.PrintBoonConsole(pp, DRB_Legacy_WeaponXP1, "+5% weapon XP");
                printed = true;
                break;
            }
            case DRB_StimpackTraining:
            {
                if (st.StimTier < 2) st.StimTier++;
                RogueBoons.PrintBoonConsole(pp, DRB_StimpackTraining, "+1 Stimpack tier");
                printed = true;
                break;
            }
            case DRB_MedikitTraining:
            {
                if (st.MedikitTier < 2) st.MedikitTier++;
                RogueBoons.PrintBoonConsole(pp, DRB_MedikitTraining, "+1 Medikit tier");
                printed = true;
                break;
            }
            case DRB_ArmorReinfI:
            case DRB_ArmorReinfII:
            {
                // Armor Reinforcement increases Steadfast stacks (DR)
                if (st.Boon_SteadfastStacks < 5) st.Boon_SteadfastStacks++;
                RogueBoons.PrintBoonConsole(pp, id, "+1 Steadfast");
                printed = true;
                break;
            }
            case DRB_DeimosBulwark:
            {
                // Deimos Bulwark increases Bulwark stacks (additional DR) up to 3
                if (st.Boon_BulwarkStacks < 3) st.Boon_BulwarkStacks++;
                RogueBoons.PrintBoonConsole(pp, DRB_DeimosBulwark, "+1 Bulwark stack");
                printed = true;
                break;
            }
            case DRB_AdrenalSurge:
            {
                st.Boon_AdrenalShield = 1;
                st.AdrenalShieldTics += 35 * 8;
RogueBoons.PrintBoonConsole(pp, DRB_AdrenalSurge, "Shield");
                printed = true;
                break;
            }
            case DRB_Legacy_WeaponXP2:
            {
                st.GlobalXPMult *= 1.10;
                if (st.GlobalXPMult > 3.0) st.GlobalXPMult = 3.0;
                RogueBoons.PrintBoonConsole(pp, DRB_Legacy_WeaponXP2, "+10% weapon XP");
                printed = true;
                break;
            }
            case DRB_AegisFrame:
            {
                st.Boon_AdrenalShield = 1;
                st.AdrenalShieldTics += 35 * 8;
                RogueBoons.PrintBoonConsole(pp, DRB_AegisFrame, "+Aegis");
                printed = true;
                break;
            }
            case DRB_SoulSiphon:
            {
                // Use the timed Soul Siphon buff logic from the primary handler.
                // Grant or upgrade the Soul Siphon boon: increment the tier up to
                // DR_SS_MAX_RANK, reset the timer and notify the player.  This
                // ensures that Soul Siphon heals work regardless of which
                // awarding function calls this case.
                st.Boon_SoulSiphon = 1;
                if (st.SoulSiphonLevel < DR_SS_MAX_RANK) st.SoulSiphonLevel++;
                st.SoulSiphonTics = int(DR_SS_BASE_DURATION * TICRATE + 0.5);
                st.SoulSiphonNotified = false;
                // Describe the heal per kill without repeating the duration.  Only include the
                // HP per kill value; the base duration is part of the boon description.
                String desc = String.Format("+%d HP/kill", st.SoulSiphonLevel);
                RogueBoons.PrintBoonConsole(pp, DRB_SoulSiphon, desc);
                int ss_rem = int(DR_SS_BASE_DURATION);
                Console.Printf(String.Format("[DR SS] Soul Siphon active (%d s remaining)", ss_rem));
                printed = true;
                break;
            }
            case DRB_SecurityArmorMk2:
            case DRB_CombatArmorMk3:
            {
                if (st.Boon_SteadfastStacks < 5) st.Boon_SteadfastStacks++;
                RogueBoons.PrintBoonConsole(pp, id, "+1 Steadfast");
                printed = true;
                break;
            }
            case DRB_UACXPSurge:
            {
                if (st.TimedXPMult < 1.5) st.TimedXPMult = 1.5;
                if (st.TimedXPTics < 35 * 10) st.TimedXPTics = 35 * 10;
                RogueBoons.PrintBoonConsole(pp, DRB_UACXPSurge, "");
                printed = true;
                break;
            }
            case DRB_BerserkRite:
            {
                if (st.Boon_SteadfastStacks < 10) st.Boon_SteadfastStacks++;
                RogueBoons.PrintBoonConsole(pp, DRB_BerserkRite, "+1 Steadfast");
                printed = true;
                break;
            }
            case DRB_QuadDamage:
            {
                // Award Quad Damage.  Add the configured number of seconds (DR_QD_SECONDS)
                // converted to tics.  Using += allows successive pickups to extend the
                // duration.  Print a toast reflecting the new duration.
                int addTics = int(DR_QD_SECONDS * TICRATE + 0.5);
                st.QuadTics += addTics;
                // Display the duration in seconds for clarity.
                // Remove the redundant extra string for Quad Damage; the description
                // already states the duration.  Passing an empty extra avoids
                // duplication.
                RogueBoons.PrintBoonConsole(pp, DRB_QuadDamage, "");
                printed = true;
                break;
            }

            // === New boon logic for beta 18 ===
            case DRB_Executioner:
            {
                // Executioner grants +10% damage vs low‑HP enemies per tier (max 2 tiers).
                // Tier 1: +10%; Tier 2: +20%.  This softens its scaling and aligns with
                // the reduced constants DR_EXEC_BONUS1/2 defined above.
                if (st.ExecutionerLevel < 2) st.ExecutionerLevel++;
                int bonus = (st.ExecutionerLevel == 1) ? 10 : 20;
                RogueBoons.PrintBoonConsole(pp, DRB_Executioner, String.Format("+%d%% vs low HP", bonus));
                printed = true;
                break;
            }
            case DRB_BulwarkShards:
            {
                // Bulwark Shards increase the tier of shard generation and maximum capacity.  Each tier grants
                // a higher number of shards per kill and a larger cap (3, 5, 7, 10).  This boon has up to 4 tiers.
                if (st.BulwarkShardLevel < 4) st.BulwarkShardLevel++;
                // Set maximum shards based on the current tier
                if (st.BulwarkShardLevel == 1) st.BulwarkShardMax = 3;
                else if (st.BulwarkShardLevel == 2) st.BulwarkShardMax = 5;
                else if (st.BulwarkShardLevel == 3) st.BulwarkShardMax = 7;
                else st.BulwarkShardMax = 10;
                // Ensure current shard count does not exceed the new maximum
                if (st.BulwarkShardCount > st.BulwarkShardMax) st.BulwarkShardCount = st.BulwarkShardMax;
                RogueBoons.PrintBoonConsole(pp, DRB_BulwarkShards, String.Format("+Shard cap %d", st.BulwarkShardMax));
                printed = true;
                break;
            }
            case DRB_StageTamer:
            {
                // Stage Tamer slows stage progression.  Tier 1: stages 10% longer; Tier 2: 15% longer.
                if (st.StageTamerLevel < 2) st.StageTamerLevel++;
                int per = (st.StageTamerLevel == 1) ? 10 : 15;
                RogueBoons.PrintBoonConsole(pp, DRB_StageTamer, String.Format("-%d%% stage speed", per));
                printed = true;
                break;
            }
            case DRB_HeavySlayer:
            {
                // Heavy Slayer grants bonus damage vs high‑HP monsters.  Tier 1: +10%; Tier 2: +20%.
                if (st.HeavySlayerLevel < 2) st.HeavySlayerLevel++;
                int per = (st.HeavySlayerLevel == 1) ? 10 : 20;
                RogueBoons.PrintBoonConsole(pp, DRB_HeavySlayer, String.Format("+%d%% vs heavies", per));
                printed = true;
                break;
            }
            case DRB_CrowdFrenzy:
            {
                // Crowd Frenzy grants a stacking damage buff when chaining kills.  Set ownership flag; stacks
                // and timers will be handled in WorldThingDied and Tick.  Subsequent pickups refresh nothing.
                st.FrenzyOwned = true;
                RogueBoons.PrintBoonConsole(pp, DRB_CrowdFrenzy, "+Frenzy buff");
                printed = true;
                break;
            }

            // === New boons for beta 22 ===
            case DRB_RaiseMaxHealth:
            {
                // Each Raise Max Health boon increases the maximum healable health by 25.  Cap at DR_RAISE_HEALTH_CAP.
                if (st != null)
                {
                    // Compute the maximum number of tiers allowed based on the cap and base.
                    int maxTiers = int((DR_RAISE_HEALTH_CAP - 200) / DR_RAISE_HEALTH_INC);
                    if (st.MaxHealthBonus < maxTiers) st.MaxHealthBonus++;
                }
                // No extra string for Raise Max Health; the description communicates
                // the +25 max HP increase.
                RogueBoons.PrintBoonConsole(pp, DRB_RaiseMaxHealth, "");
                printed = true;
                break;
            }
            case DRB_RaiseMaxHealthMinor:
            {
                // Minor Raise Max Health grants a small +5 HP increase to the healable maximum.  Accumulate
                // indefinitely but clamp the resulting cap inside HealCapped() via DR_RAISE_HEALTH_CAP.
                if (st != null)
                {
                    st.MinorHealthBonus++;
                }
                // Minor Raise Max Health: omit the extra string; description covers the +5
                RogueBoons.PrintBoonConsole(pp, DRB_RaiseMaxHealthMinor, "");
                printed = true;
                break;
            }
            case DRB_RaiseMaxArmor:
            {
                // Each Raise Max Armor boon increases the maximum armour by 25.  Cap at DR_RAISE_ARMOR_CAP.
                if (st != null)
                {
                    int maxTiers = int((DR_RAISE_ARMOR_CAP - DR_MAX_ARMOR_CAP) / DR_RAISE_ARMOR_INC);
                    if (st.MaxArmorBonus < maxTiers) st.MaxArmorBonus++;
                    // Update the player's armour inventory so the new cap applies immediately.
                    let ba = BasicArmor(pp.FindInventory('BasicArmor'));
                    if (ba)
                    {
                        int cap = DR_MAX_ARMOR_CAP + st.MaxArmorBonus * DR_RAISE_ARMOR_INC;
                        if (cap > DR_RAISE_ARMOR_CAP) cap = DR_RAISE_ARMOR_CAP;
                        ba.MaxAmount = cap;
                        if (ba.Amount > cap) ba.Amount = cap;
                    }
                }
                // Raise Max Armor: omit extra magnitude; description states +25 max armor.
                RogueBoons.PrintBoonConsole(pp, DRB_RaiseMaxArmor, "");
                printed = true;
                break;
            }
            case DRB_MaxHealthDamage:
            {
                // Apply the extra damage at max health boon.  This is permanent; subsequent
                // pickups have no additional effect.
                if (st != null) st.MaxHealthDamage = true;
                RogueBoons.PrintBoonConsole(pp, DRB_MaxHealthDamage, "+25% dmg at max HP");
                printed = true;
                break;
            }
            case DRB_BerserkingFirepower:
            {
                // Apply the Berserking Firepower boon: permanent +15% global damage.  This
                // replaces the previous +20% bonus to reduce synergy with level and over
                // multipliers.  Subsequent pickups still have no further effect.
                if (st != null) st.BerserkFirepower = true;
                // Berserking Firepower already conveys its effect (+15% global damage).  Do not
                // repeat the magnitude in the extra string.
                RogueBoons.PrintBoonConsole(pp, DRB_BerserkingFirepower, "");
                printed = true;
                break;
            }
            case DRB_TimeRewind:
            {
                // Apply the Time Rewind boon: subtract one stage’s worth of time from the run timer.
                if (st != null)
                {
                    double skillMul = RogueDifficultyHandler.GetSkillTimeMul();
                    double minutes = DR_STAGE_BASE_MIN * skillMul;
                    int rewindTics = int(minutes * 60.0 * TICRATE + 0.5);
                    if (st.RunTimerSec > rewindTics) st.RunTimerSec -= rewindTics; else st.RunTimerSec = 0;
                    st.TimeRewindUsed++;
                }
                RogueBoons.PrintBoonConsole(pp, DRB_TimeRewind, "-1 Stage");
                printed = true;
                break;
            }
        }

        // Ensure we at least print the boon name if no specific effect logged
        if (!printed) ConsoleBoon(pp, id);
    }
}

class RogueDifficultyHandler
{
    static double GetSkillTimeMul() {
        int s = CVar.GetCVar("skill").GetInt();
        if (s == 0) return 0.80;
        if (s == 1) return 0.90;
        if (s == 2) return 1.00;
        if (s == 3) return 1.12;
        return 1.25;
    }
    static bool ShouldTick()
{
        if (DR_TIMER_PAUSE_IF_NO_PLAYERS != 0)
        {
            bool any = false;
            for (int i = 0; i < MAXPLAYERS; i++)
            {
                if (players[i].mo != null && players[i].playerstate == PST_LIVE)
                {
                    any = true;
                    break;
                }
            }
            if (!any) return false;
        }
        if (DR_TIMER_PAUSE_IN_INTERMISSION != 0 && gamestate != GS_LEVEL) return false;
        return true;
    }
    static double CalculateDifficultyScale(double runMinutes) {
        if (runMinutes < 0.0) runMinutes = 0.0;
        double effectiveMinutes = runMinutes * GetSkillTimeMul();
        int steps = int(effectiveMinutes);
        double scale = 1.0;
        for (int i = 0; i < steps; i++) scale *= DR_DIFFICULTY_PER_MINUTE_EXPONENT;
        scale *= DR_DIFFICULTY_BASE;
        if (scale < 1.0) scale = 1.0;
        if (scale > DR_DIFFICULTY_MAX_SCALE) scale = DR_DIFFICULTY_MAX_SCALE;
        return scale;
    }
    ui static String GetDifficultyTierName(double scale) {
        int stage = int(scale);
        if (stage < 1) stage = 1;
        return String.Format("Stage %d", stage);
    }
    ui static int GetDifficultyTierColor(double scale) {
        if (scale < 1.5) return Font.CR_GREEN;
        if (scale < 2.5) return Font.CR_YELLOW;
        if (scale < 4.0) return Font.CR_ORANGE;
        if (scale < 6.0) return Font.CR_RED;
        if (scale < 10.0) return Font.CR_DARKRED;
        return Font.CR_PURPLE;
    }
}




// --------- Pickup proxies (keep DECORATE actors untouched; swap at spawn) --
class DR_ArmorBonusProxy : ArmorBonus
{
    override bool TryPickup(in out Actor toucher)
    {
        bool ok=Super.TryPickup(toucher);
        PlayerPawn pp=PlayerPawn(toucher);
        if(!ok||!pp) return ok;
        RogueStats st=RogueCoreHandler.GetOrGiveStats(pp);
        if(!st) return ok;
        int extra=st.ArmorBonusStacks;
        if(extra>0) RogueBoons.ArmorGrantScaled(pp, extra, st);
        return ok;
    }
}
class DR_StimpackProxy : Stimpack
{
    override bool TryPickup(in out Actor toucher)
    {
        PlayerPawn pp = PlayerPawn(toucher);
        if (!pp) return false;
        bool picked = Super.TryPickup(toucher);
        RogueStats st = RogueCoreHandler.GetOrGiveStats(pp);
        if (!st) return picked;
        int add = st.StimTier * DR_STIM_PER_T;
        if (add > 0) { RogueBoons.HealCapped(pp, add, true); picked = true; }
        return picked;
    }
}
class DR_MedikitProxy : Medikit
{
    override bool TryPickup(in out Actor toucher)
    {
        PlayerPawn pp = PlayerPawn(toucher);
        if (!pp) return false;
        bool picked = Super.TryPickup(toucher);
        RogueStats st = RogueCoreHandler.GetOrGiveStats(pp);
        if (!st) return picked;
        int add = st.MedikitTier * DR_MEDI_PER_T;
        if (add > 0) { RogueBoons.HealCapped(pp, add, true); picked = true; }
        return picked;
    }
}
class DR_HealthBonusProxy : HealthBonus
{
    override bool TryPickup(in out Actor toucher)
    {
        PlayerPawn pp=PlayerPawn(toucher);
        bool ok=Super.TryPickup(toucher);
        if(!ok||!pp) return ok;
        RogueStats st=RogueCoreHandler.GetOrGiveStats(pp);
        if(!st) return ok;
        int add=st.BlueVialStacks;
        if(add>0) RogueBoons.HealCapped(pp, add, true);
        return ok;
    }
}
class DR_SoulSphereProxy : SoulSphere
{
    override bool TryPickup(in out Actor toucher)
    {
        // Modified Soulsphere pickup: always grant +100 HP (plus Supercharge stacks) relative to current health
        // and allow overheal beyond the vanilla 200 HP cap when Raise Max Health boons are active.  To
        // preserve the pickup sound and message we call the base TryPickup first, then adjust the player's
        // health based on their state prior to the pickup.  See discussion in Issue #29.
        PlayerPawn pp = PlayerPawn(toucher);
        if (!pp) return false;
        // Record the player's health before the base Supercharge effect applies so we can compute the
        // total amount of healing to apply.  Do this up front because Super.TryPickup() will reset
        // health to 200.
        int oldHealth = pp.health;
        bool ok = Super.TryPickup(toucher);
        if (!ok) return ok;
        // Acquire stats after base pickup so that stats exist on new players.
        RogueStats st = RogueCoreHandler.GetOrGiveStats(pp);
        // Determine additional heal from Supercharge stacks.  Each stack adds 25 HP on top of the base +100.
        int extra = 0;
        if (st != null && st.SuperchargeStacks > 0) extra = st.SuperchargeStacks * 25;
        // Desired new health: current health prior to pickup +100 HP + any stack bonus.
        int newWanted = oldHealth + 100 + extra;
        // Compute the dynamic health cap (base 200 plus Raise Max Health tiers).  Mirror HealCapped().
        int cap = DR_MAX_HEALTH_CAP;
        if (st != null)
        {
            cap = DR_MAX_HEALTH_CAP
                + st.MaxHealthBonus * DR_RAISE_HEALTH_INC
                + st.MinorHealthBonus * DR_RAISE_HEALTH_MINI_INC;
            if (cap > DR_RAISE_HEALTH_CAP) cap = DR_RAISE_HEALTH_CAP;
        }
        if (newWanted > cap) newWanted = cap;
        // Base TryPickup() leaves the player at 200 HP; adjust up or down to reach the desired target.
        if (newWanted > 200)
        {
            // Heal the difference beyond the base 200 HP.  Allow overheal by passing allow200=true.
            int addAmt = newWanted - 200;
            RogueBoons.HealCapped(pp, addAmt, true);
        }
        else if (newWanted < 200)
        {
            // Clamp down if the desired health is below the base supercharge value (e.g. when the
            // player was under 100 HP before pickup).  Directly set health rather than healing.
            pp.health = newWanted;
        }
        return ok;
    }
}

// Proxy for the Berserk pack.  When picked up, grants the usual Berserk effect and
// awards one level of XP to the Fist weapon.  This balances the Fist, which
// otherwise receives little use later in the game.  The proxy replaces the
// vanilla Berserk actor via WorldThingSpawned.
class DR_BerserkProxy : Berserk
{
    override bool TryPickup(in out Actor toucher)
    {
        bool ok = Super.TryPickup(toucher);
        PlayerPawn pp = PlayerPawn(toucher);
        if (!ok || !pp) return ok;
        RogueStats st = RogueCoreHandler.GetOrGiveStats(pp);
        if (!st) return ok;
        int widx = RW_Fist;
        int need = RogueXP.RequiredForNext(st.Level[widx], widx);
        st.AddXP(widx, need);
        return ok;
    }
}
class DR_GreenArmorProxy : GreenArmor {
    override bool TryPickup(in out Actor toucher) {
        bool ok=Super.TryPickup(toucher);
        PlayerPawn pp=PlayerPawn(toucher); if(!ok||!pp) return ok;
        RogueStats st=RogueCoreHandler.GetOrGiveStats(pp); if(!st) return ok;
        let ba=BasicArmor(pp.FindInventory('BasicArmor')); if(!ba) return ok;

        if (st.Boon_SecurityMk2) { ba.Amount = ba.Amount + 50; }

        double mul = RogueUtil.Powd(1.15, st.Boon_ArmorReinfI) * RogueUtil.Powd(1.25, st.Boon_ArmorReinfII);
        if (mul > 1.0001) ba.Amount = int(double(ba.Amount) * mul + 0.5);
        if (ba.Amount > DR_MAX_ARMOR_CAP) ba.Amount = DR_MAX_ARMOR_CAP;
        return ok;
    }
}

class DR_BlueArmorProxy : BlueArmor {
    override bool TryPickup(in out Actor toucher) {
        bool ok=Super.TryPickup(toucher);
        PlayerPawn pp=PlayerPawn(toucher); if(!ok||!pp) return ok;
        RogueStats st=RogueCoreHandler.GetOrGiveStats(pp); if(!st) return ok;
        let ba=BasicArmor(pp.FindInventory('BasicArmor')); if(!ba) return ok;

        if (st.Boon_CombatMk3) { ba.Amount = ba.Amount + 100; }

        double mul = RogueUtil.Powd(1.15, st.Boon_ArmorReinfI) * RogueUtil.Powd(1.25, st.Boon_ArmorReinfII);
        if (mul > 1.0001) ba.Amount = int(double(ba.Amount) * mul + 0.5);
        if (ba.Amount > DR_MAX_ARMOR_CAP) ba.Amount = DR_MAX_ARMOR_CAP;
        return ok;
    }
}

// Proxy for the Megasphere (full megasphere powerup).  The vanilla Megasphere
// sets the player's health and armour to 200 regardless of their existing
// reserves.  In Doom Rogue we instead want to grant a **+200 HP** and
// **+200 armour** bonus relative to the player's current values and allow
// exceeding the vanilla 200 limit when Raise Max Health or Raise Max Armor
// boons are active.  This proxy preserves the default pickup sound and
// message by calling Super.TryPickup() first, then applies the scaled
// healing and armour increments based on the player's state prior to the
// pickup.
class DR_MegasphereProxy : Megasphere
{
    override bool TryPickup(in out Actor toucher)
    {
        PlayerPawn pp = PlayerPawn(toucher);
        if (!pp) return false;
        // Record pre-pickup health and armour to compute deltas after the base effect.
        int oldHealth = pp.health;
        int oldArmor  = 0;
        let baPrev = BasicArmor(pp.FindInventory('BasicArmor'));
        if (baPrev != null) oldArmor = baPrev.Amount;
        bool ok = Super.TryPickup(toucher);
        if (!ok) return ok;
        RogueStats st = RogueCoreHandler.GetOrGiveStats(pp);
        // Adjust health: base Megasphere sets HP to 200.  We want oldHealth + 200, clamped to the dynamic cap.
        int desiredHP = oldHealth + 200;
        // Compute dynamic health cap (base 200 plus Raise Max Health tiers).  Mirror HealCapped().
        int capHP = DR_MAX_HEALTH_CAP;
        if (st != null)
        {
            capHP = DR_MAX_HEALTH_CAP
                + st.MaxHealthBonus * DR_RAISE_HEALTH_INC
                + st.MinorHealthBonus * DR_RAISE_HEALTH_MINI_INC;
            if (capHP > DR_RAISE_HEALTH_CAP) capHP = DR_RAISE_HEALTH_CAP;
        }
        if (desiredHP > capHP) desiredHP = capHP;
        if (desiredHP > 200)
        {
            // Heal the amount beyond the base 200 HP; allow overheal.
            int addHP = desiredHP - 200;
            RogueBoons.HealCapped(pp, addHP, true);
        }
        else if (desiredHP < 200)
        {
            // If desired HP is less than 200, lower the health accordingly.
            pp.health = desiredHP;
        }
        // Adjust armour: base Megasphere sets armour to 200.  We want oldArmor + 200, clamped to the dynamic cap.
        let ba = BasicArmor(pp.FindInventory('BasicArmor'));
        if (ba != null)
        {
            int desiredArm = oldArmor + 200;
            // Compute dynamic armour cap: base 200 plus Raise Max Armor tiers.  Mirror ArmorGrantScaled().
            int capArm = DR_MAX_ARMOR_CAP + ((st != null) ? st.MaxArmorBonus * DR_RAISE_ARMOR_INC : 0);
            if (capArm > DR_RAISE_ARMOR_CAP) capArm = DR_RAISE_ARMOR_CAP;
            if (desiredArm > capArm) desiredArm = capArm;
            ba.MaxAmount = capArm;
            ba.Amount = desiredArm;
        }
        return ok;
    }
}



class DR_HPStamp : Inventory
{
    Default { Inventory.MaxAmount 1; +INVENTORY.UNDROPPABLE; +INVENTORY.QUIET; +INVENTORY.KEEPDEPLETED; +INVENTORY.HUBPOWER; }
    int MaxHP;
}


// Tracks applied HP scale on a monster so we can bump once per stage without repeats
class DR_MonHPScale : Inventory
{
    double applied;
    Default { Inventory.MaxAmount 1; +INVENTORY.UNDROPPABLE; +INVENTORY.UNTOSSABLE; }
}
class RogueCoreHandler : EventHandler
{
    // Sweep state for real-time scaling of already-spawned monsters
    bool HPStageSweepActive;
    int  HPStageLast ;
    // HPIt holds a pointer to the currently iterated ThinkerIterator when performing
    // a monster health sweep.  This field must not be serialized, since GZDoom
    // cannot restore abstract classes from savegames.  Without marking it as
    // transient, reloading a game (or respawning) would attempt to instantiate
    // ThinkerIterator, triggering a "Attempt to instantiate abstract class
    // ThinkerIterator" crash.  Declaring it transient excludes it from
    // serialization and avoids this crash.
    transient ThinkerIterator HPIt;
    double HPStageTarget;

    void BeginHPSweep(int stage, double target)
    {
        HPStageTarget = target;
        HPIt = ThinkerIterator.Create("Actor");
        HPStageSweepActive = true;
    }

// === DR NOTE [0.5.259] â 2025-09-02 19:52:47 EDT â Section: Timer Stages â WorldTick() sweep (64 actors/tic) ===
// === DR CHECKLIST [0.5.260] â 2025-09-02 19:55:49 EDT â WorldTick() Sweep ===
// [x] CODE: Processes up to 64 actors/tic (throttled)
// [x] CODE: Applies delta scaling using DR_MonHPScale.applied
// [ ] REVIEW: Confirm coop performance on 300+ monsters maps
// Confidence: 99.2000% | Completion: 96%
// Future attacks:
//  â¢ Track last-sweep count for perf telemetry (debug only)
//  â¢ Consider prioritizing active/awake monsters first
// Bookmarks: [DR_NOTE_TimerStagesWorldTicksweep64actorstic]
    override void WorldTick()
    {
        // Note: level.NetMode and NM_Client are unavailable in this engine
        // version, so the netguard has been removed.  In singleâplayer this
        // has no effect; in multiplayer the server should handle HP scaling.

        super.WorldTick();
        // Check for stage advance
        double target = DR_GetHPScale();
// === DR CHECKLIST [0.5.260] â 2025-09-02 19:55:49 EDT â DR_GetHPScale() 5-Stage Timer ===
// [x] CODE: Stage table = [1.00,1.15,1.30,1.45,1.60,1.75]
// [x] CODE: Stage window = 3.0m Ã skill multiplier
// [x] CODE: st.DifficultyScale pulls from DR_GetHPScale()
// [ ] USER: Stage jumps feel fair on HMP/UV; not too spiky
        // Convert the current HP scale into a stage index.  Using the revised
        // stage table where Stage0=1.00, Stage1≈1.08, Stage2≈1.17, Stage3≈1.27,
        // Stage4≈1.38, Stage5≈1.50 and beyond +0.10 increments, derive the
        // integer stage number by dividing the excess scale by 0.10.  Clamp to
        // zero.
        int stage = 0;
        if (target > 1.0)
        {
            // Derive the stage index based on the beta 13 increment of 0.07× per
            // stage.  Subtract 1.0 and divide by 0.07 to estimate stage.  Add
            // a small epsilon to avoid rounding issues.
            stage = int(floor((target - 1.0) / 0.07 + 0.0001));
            if (stage < 0) stage = 0;
        }
        // When the stage advances beyond the last processed stage, start a new
        // HP sweep and report the progression to the console.  Include the
        // elapsed run time and the new scale for easier tuning.  Use the
        // playerâs RunTimerSec to compute MM:SS; if unavailable, fall back
        // to level.maptime.  This logging aids balance tuning in playtests.
        if (stage > HPStageLast)
        {
            int runSec = 0;
            // find first player stats for timer
            for (int j = 0; j < MAXPLAYERS; j++)
            {
                if (players[j].mo != null)
                {
                    RogueStats st_notify = GetOrGiveStats(PlayerPawn(players[j].mo));
                    if (st_notify != null) { runSec = st_notify.RunTimerSec; break; }
                }
            }
            // Convert the run timer from tics to minutes and seconds for logging.
            int mm;
            int ss;
            if (runSec > 0)
            {
                int totalSecs = runSec / TICRATE;
                mm = totalSecs / 60;
                ss = totalSecs % 60;
            }
            else
            {
                int totalSecs = int(level.maptime / TICRATE);
                mm = totalSecs / 60;
                ss = totalSecs % 60;
            }
            // Include Stage Tamer modifier in the log if active.
            int tamerTierLog = 0;
            for (int j2 = 0; j2 < MAXPLAYERS; j2++)
            {
                if (players[j2].mo != null)
                {
                    RogueStats st_log = GetOrGiveStats(PlayerPawn(players[j2].mo));
                    if (st_log != null && st_log.StageTamerLevel > tamerTierLog)
                    {
                        tamerTierLog = st_log.StageTamerLevel;
                    }
                }
            }
            String tamerStr = "";
            if (tamerTierLog > 0)
            {
                int per = (tamerTierLog == 1) ? 10 : 15;
                tamerStr = String.Format(" (Tamer -%d%%)", per);
            }
            Console.Printf(String.Format("[DR STAGE] Stage %d reached (scale %.2fx) at %02d:%02d%s", stage, target, mm, ss, tamerStr));
            // Record the new stage immediately to avoid repeated stage logs on
            // subsequent ticks.  HPStageLast will also be updated at the end
            // of the sweep, but updating here prevents spamming when no
            // monsters are present and the sweep terminates immediately.
            HPStageLast = stage;
            BeginHPSweep(stage, target);
        }
        // Process a limited number per tic
        if (HPStageSweepActive && HPIt != null)
        {
            int processed = 0;
            while (processed < 64)
            {
                let mo = Actor(HPIt.Next());
                if (mo == null)
                {
                    HPStageSweepActive = false;
                    HPIt = null;
                    HPStageLast = stage;
                    break;
                }
                if (!mo.bIsMonster) { processed++; continue; }
                DR_MonHPScale tag = DR_MonHPScale(mo.FindInventory("DR_MonHPScale"));
                if (tag == null)
                {
                    mo.GiveInventory("DR_MonHPScale",1);
                tag = DR_MonHPScale(mo.FindInventory("DR_MonHPScale"));
                    if (tag != null) tag.applied = 1.0;
                }
                if (tag != null && tag.applied + 0.001 < HPStageTarget)
                {
                    double factor = HPStageTarget / max(tag.applied, 1.0);
                    int nh = int(ceil(mo.health * factor));
                    if (nh > mo.health) mo.health = nh;
                    tag.applied = HPStageTarget;
                }
                processed++;
            }
        }
        // -- merged from later WorldTick (timer/cheats/toasts) --
    {
        if (RogueDifficultyHandler.ShouldTick())
        {
            if (players[0].mo != null) {
                RogueStats st0 = GetOrGiveStats(players[0].mo);
                if(st0) st0.RunTimerSec++;
            }
        }

        for (int i = 0; i < MAXPLAYERS; i++)
        {
            PlayerInfo pi = players[i]; if (!pi || !pi.mo) continue;
            PlayerPawn pp = PlayerPawn(pi.mo);
            RogueStats st = GetOrGiveStats(pp); if (!st) continue;

            if(i > 0 && players[0].mo)
            {
                RogueStats st_master = GetOrGiveStats(players[0].mo);
                if(st_master) st.RunTimerSec = st_master.RunTimerSec;
            }

            st.DifficultyScale = RogueCoreHandler.DR_GetHPScale();
            st.CurrentWeaponIndex = SnapWeaponIndex(pp);
            // Tick down timers and emit debug messages when Quad Damage begins or ends.
            // Quad Damage: decrement tics, then check if state changed for this player.
            // Track previous timer states so we can emit expiration logs.
            bool quadPrev    = (st.QuadTics > 0);
            bool xpPrev      = (st.TimedXPTics > 0);
            bool adrenalPrev = (st.AdrenalShieldTics > 0);
            bool brPrev      = (st.BloodRiteTics > 0);
            bool ssPrev      = (st.SoulSiphonTics > 0);
            // Decrement timers once per tick.  If a timer reaches zero
            // this frame we may need to log its expiration below.
            if (st.QuadTics > 0) st.QuadTics--;
            if (st.TimedXPTics > 0) st.TimedXPTics--;
            if (st.AdrenalShieldTics > 0) st.AdrenalShieldTics--;
            if (st.BloodRiteTics > 0) st.BloodRiteTics--;
            if (st.SoulSiphonTics > 0) st.SoulSiphonTics--;
            if (st.LevelUpTics > 0) st.LevelUpTics--;
            // Evaluate quad status changes and log accordingly.
            bool quadNow = (st.QuadTics > 0);
            if (!st.QuadActiveNotified && quadNow)
            {
                st.QuadActiveNotified = true;
                int remSec = int(ceil(double(st.QuadTics) / TICRATE));
                Console.Printf(String.Format("[DR QUAD] Quad Damage active (%d s remaining)", remSec));
            }
            else if (st.QuadActiveNotified && !quadNow)
            {
                st.QuadActiveNotified = false;
                Console.Printf("[DR QUAD] Quad Damage expired");
            }
            // Log expiration of timed XP bonus and adrenal shield.
            bool xpNow = (st.TimedXPTics > 0);
            if (xpPrev && !xpNow)
            {
                Console.Printf("[DR XP] Timed XP bonus expired");
            }
            bool adrenalNow = (st.AdrenalShieldTics > 0);
            if (adrenalPrev && !adrenalNow)
            {
                Console.Printf("[DR SHIELD] Adrenal Shield expired");
            }

            bool brNow = (st.BloodRiteTics > 0);
            if (brPrev && !brNow && st.BloodRiteOwned)
            {
                Console.Printf("[DR RITE] Blood Rite expired");
            }

            // Soul Siphon: log activation/expiration messages once per cycle.  Use
            // SoulSiphonNotified to avoid duplicate announcements.  When
            // SoulSiphonTics transitions from 0 to positive, print the
            // remaining duration in seconds.  When it drops to zero, print
            // an expiration message.
            bool ssNow = (st.SoulSiphonTics > 0);
            if (!st.SoulSiphonNotified && ssNow)
            {
                st.SoulSiphonNotified = true;
                int remSec = int(ceil(double(st.SoulSiphonTics) / TICRATE));
                Console.Printf(String.Format("[DR SS] Soul Siphon active (%d s remaining)", remSec));
            }
            else if (st.SoulSiphonNotified && !ssNow)
            {
                st.SoulSiphonNotified = false;
                Console.Printf("[DR SS] Soul Siphon expired");
            }


            if (i == consoleplayer)
            {
                CVar cvL = CVar.GetCVar("dr_lvlup");
                int want = (cvL ? cvL.GetInt() : 0);
                if (st.LvlupSeen < want)
                {
                    int delta = want - st.LvlupSeen;
                    st.LvlupSeen = want;

                    int widx = SnapWeaponIndex(pp);
                    if (widx >= 0 && widx < RW_Count)
                    {
                        while (delta-- > 0)
                        {
                            int before = st.Level[widx];
                            st.Level[widx]++;

                            int newLvl = st.Level[widx];
                            st.LastLeveledIndex = widx;
                            st.LastLeveledOldLevel = before;
                            st.LastLeveledNewLevel = newLvl;
                            st.LevelUpTics = LEVELUP_TICS;

                            st.LastDmgOldPct = int(RogueDamage.MultForLevel(before) * 100.0 + 0.5);
                            st.LastDmgNewPct = int(RogueDamage.MultForLevel(newLvl) * 100.0 + 0.5);

                            RogueBoons.OnLevelUp(pp, st, widx, newLvl);
                        }
                        pp.A_Log(String.Format("CHEAT: weapon leveled to Lv %d.", st.Level[widx]));
                    }
                }

                CVar cvB = CVar.GetCVar("dr_boon");
                int bWant = (cvB ? cvB.GetInt() : 0);
                if (st.BoonCheatSeen < bWant)
                {
                    int tier = CVar.GetCVar("dr_boon_tier") ? CVar.GetCVar("dr_boon_tier").GetInt() : 1;
                    tier = DRPatchHelpers.Clampd(tier, 1, 5);

                    int delta = bWant - st.BoonCheatSeen;
                    st.BoonCheatSeen = bWant;

                    while (delta-- > 0)
                    {
                        int widx2 = SnapWeaponIndex(pp);
                        DRBoonId pick = RogueBoons.PickCheatFromTier(st, widx2, tier);
                        RogueBoons.ApplyBoon(pp, st, widx2, st.Level[widx2], pick);
}
                }
            }
        }
    }

    // ===== Dynamic monster HP scaling (map-time based) =====

// (removed stray return)
// (removed stray brace)


}
    HUDFont sHudF;
    override void WorldLoaded(WorldEvent e)
    {
        // init sweep vars
        HPStageLast = -1;
        HPIt = null;
        HPStageTarget = 1.0;
        if (__dr_echo_done == 0) { if (DebugOn()) DLog(null, "[DOOM ROGUE] Init"); __dr_echo_done = 1; }
        // Reset per‑map caps on all players.  This resets Soul Siphon usage and other
        // counters that should refresh when the level changes.  Acquire stats
        // objects for each live player and call ResetPerMapCaps().
        for (int i = 0; i < MAXPLAYERS; i++)
        {
            if (players[i].mo != null)
            {
                RogueStats st = GetOrGiveStats(PlayerPawn(players[i].mo));
                if (st != null) st.ResetPerMapCaps();
            }
        }
        Super.WorldLoaded(e);
    }

    // Log throttle + startup echo state
    double __dr_log_tokens;
    int __dr_log_lasttic;
    int __dr_echo_done;

    static bool IsOurPickupProxy(Actor a)
    {
        return a is 'DR_ArmorBonusProxy' || a is 'DR_StimpackProxy' || a is 'DR_MedikitProxy' || a is 'DR_HealthBonusProxy' ||
               a is 'DR_SoulSphereProxy' || a is 'DR_MegasphereProxy' || a is 'DR_GreenArmorProxy' || a is 'DR_BlueArmorProxy';
    }
    static bool DebugOn() {
        CVar c = CVar.GetCVar("dr_dbg");
        // Default debug on when CVAR is absent; user can disable by setting dr_dbg=0.
        return (!c || c.GetInt() != 0);
    }
    static int  DebugLevel() { CVar c = CVar.GetCVar("dr_dbg"); return c ? c.GetInt() : 1; }
    void DLog(PlayerPawn who, String s)
{
    int now = level.time;
    double rate = 50.0; CVar cr = CVar.GetCVar("dr_log_rate"); if (cr) { double v = cr.GetFloat(); if (v > 1 && v < 5000) rate = v; }
    int dt = now - __dr_log_lasttic; if (dt < 0) dt = 0; __dr_log_lasttic = now;
    __dr_log_tokens += (rate/35.0) * dt; if (__dr_log_tokens > rate) __dr_log_tokens = rate;
    if (__dr_log_tokens < 1.0) return; __dr_log_tokens -= 1.0;
    if (who) who.A_Log(s); else Console.Printf(s);
}





    static PlayerInfo PawnToPlayerInfo(PlayerPawn pp)
{
    if (pp == null) return null;
    for (int i = 0; i < MAXPLAYERS; i++)
    {
        PlayerInfo pi = players[i];
        if (pi && pi.mo == pp) return pi;
    }
    return null;
}

static RogueStats GetOrGiveStats(PlayerPawn pp)
{
    if (pp == null) return null;
    RogueStats st = RogueStats(pp.FindInventory('RogueStats'));
    if (st == null)
    {
        let a = Actor.Spawn('RogueStats', pp.pos, ALLOW_REPLACE);
        if (a)
        {
            st = RogueStats(a);
            pp.AddInventory(st);
        }
    }
    return st;
}
    static int SnapWeaponIndex(PlayerPawn pp)
{
    PlayerInfo pi = PawnToPlayerInfo(pp);
    if (pi && pi.ReadyWeapon)
    {
        int widx = RogueUtil.WeaponToIndex(pi.ReadyWeapon);
        if (widx >= 0 && widx < RW_Count) return widx;
    }
    return -1;
}


    override void WorldThingDamaged(WorldEvent e)
    {
        // Guard against recursive damage from Executioner and Heavy Slayer.  If the damage
        // originates from our own bonus damage types, do not apply Executioner/Heavy
        // logic again.  Without this check, calling DamageMobj() below would trigger
        // WorldThingDamaged a second time and overflow the stack when using rapid‑fire
        // weapons like the BFG.
        Name dt = e.DamageType;
        bool isExec = (dt == 'Exec');
        bool isHeavy = (dt == 'Heavy');
        
        if (e.Thing) { DR_HPStamp __hs = DR_HPStamp(e.Thing.FindInventory("DR_HPStamp")); if (__hs && __hs.MaxHP < e.Thing.Health) __hs.MaxHP = e.Thing.Health; }
        if (e.Damage <= 0) return;
        if (e.DamageSource == e.Thing) return;

        // OUTGOING: player -> monster
        PlayerPawn pp_source = PlayerPawn(e.DamageSource);
        if (pp_source)
        {
            RogueStats st = GetOrGiveStats(pp_source);
            if (st)
            {
                int widx = SnapWeaponIndex(pp_source);
                if (widx != -1)
                {
                    double baseD = double(e.Damage);
                    double lvlMult = RogueDamage.MultForLevel(st.Level[widx]);
                    double overMult = RogueBoons.OverMultFor(st, widx);
                    double globalMult = st.GlobalDmgMult;
                    double quadMult = (st.QuadTics > 0) ? DR_QD_MULT : 1.0;
                    double totalMult = lvlMult * overMult * globalMult * quadMult;
                    // Clean English on-hit log (gated by dr_dbg_hits).
                    CVar cHits = CVar.GetCVar("dr_dbg_hits");
                    if (cHits && cHits.GetInt() != 0 && e.Thing.bIsMonster)
                    {
                        int baseHP = e.Thing.SpawnHealth();
                        // Determine the scaling factor for this monster: either the stored
                        // applied value on DR_MonHPScale or the current stage scale.
                        double scale = 1.0;
                        DR_MonHPScale tag = DR_MonHPScale(e.Thing.FindInventory("DR_MonHPScale"));
                        if (tag != null)
                            scale = max(1.0, tag.applied);
                        else
                            scale = max(1.0, DR_GetHPScale());
                        int scaledMax = int(ceil(double(baseHP) * scale));
                        String wname = RogueUtil.IndexToName(widx);
                        int lvlNow = st.Level[widx];
                        int curHP = e.Thing.health;
                        // Derive a stage index from the scale factor for easier reading.  The
                        // first stage corresponds to a 1.00× scale; each additional stage
                        // adds 0.15× to the previous one (beyond stage 5).  Compute an
                        // approximate stage number by subtracting 1.0 and dividing by 0.15.
                        int stageNum = 0;
                        if (scale > 1.0)
                        {
                            // With the beta 11 stage table each stage after the first
                            // adds 0.08×.  Derive the approximate stage number by
                            // subtracting 1.0 and dividing by 0.08.  Clamp to at least 1.
                            stageNum = 1 + int(((scale - 1.0) / 0.08) + 0.5);
                            if (stageNum < 1) stageNum = 1;
                        }
                        Console.Printf("Hit: %s (Lvl %d) dealt %d | Target HP %d/%d | Stage %d Scale %.2fx (base %d)",
                            wname, lvlNow, e.Damage, curHP, scaledMax, stageNum, scale, baseHP);
                    }
                }

            // Apply knockback reduction.  When the player damages a monster,
            // the base DOOM engine applies thrust proportional to damage and
            // inversely proportional to target mass.  With high weapon
            // multipliers monsters can be propelled unrealistically far.  To
            // preserve the classic feel, scale the victim’s horizontal
            // velocity after damage.  Only apply when the damage source is
            // the player and the victim is a monster.  Vertical velocity is
            // left untouched to allow proper arch‑vile jumps and lifts.
            Actor tgt = e.Thing;
            if (tgt && tgt.bIsMonster)
            {
                // Avoid scaling heavy actors such as bosses by checking
                // mass.  DOOM’s mass is roughly proportional to HP; ignore
                // knockback scaling for actors above 500 mass (Cyberdemon,
                // Spider Mastermind) so their movement feels correct.
                int m = tgt.mass;
                if (m < 500)
                {
                    vector3 v = tgt.Vel;
                    v.x *= DR_KNOCKBACK_SCALE;
                    v.y *= DR_KNOCKBACK_SCALE;
                    tgt.Vel = v;
                }
            }

            // Apply Executioner and Heavy Slayer extra damage after the base hit.
            // Only run this logic when the incoming damage is not itself from
            // Executioner or Heavy Slayer (see dt guard above).  Without this
            // check, DamageMobj() would trigger WorldThingDamaged again and cause
            // an infinite recursion, particularly with high‑rate weapons.
            if (!isExec && !isHeavy && tgt && tgt.bIsMonster)
            {
                int baseHP = tgt.SpawnHealth();
                int curHP  = tgt.health;
                // Executioner: check low‑HP threshold.  When the victim’s current
                // HP is at or below the configured percentage of its spawn health,
                // apply bonus damage proportional to the original hit.  Use a
                // dedicated damage type to mark this extra damage so it will not
                // re‑enter this logic recursively.
                if (st.ExecutionerLevel > 0 && baseHP > 0)
                {
                    double threshold = double(baseHP) * DR_EXEC_THRESHOLD;
                    if (curHP <= int(threshold + 0.5))
                    {
                        double bonus = (st.ExecutionerLevel == 1) ? DR_EXEC_BONUS1 : DR_EXEC_BONUS2;
                        int extra    = int(ceil(double(e.Damage) * bonus));
                        if (extra > 0)
                        {
                            tgt.DamageMobj(pp_source, e.Inflictor, extra, 'Exec');
                            // Log executioner bonus
                            CVar cDbgExec = CVar.GetCVar("dr_dbg_hits");
                            if (cDbgExec && cDbgExec.GetInt() != 0)
                            {
                                pp_source.A_Log(String.Format("[DR DMG] Executioner +%d%% (HP %d/%d)", int(bonus*100.0 + 0.5), curHP, baseHP));
                            }
                        }
                    }
                }
                // Heavy Slayer: bonus vs high‑HP enemies.  If the target’s
                // spawn health exceeds the minimum threshold, apply bonus
                // damage.  Use a dedicated damage type to prevent recursion.
                if (st.HeavySlayerLevel > 0 && baseHP >= DR_HEAVY_MIN_HP)
                {
                    double hbonus = (st.HeavySlayerLevel == 1) ? DR_HEAVY_BONUS1 : DR_HEAVY_BONUS2;
                    int hExtra    = int(ceil(double(e.Damage) * hbonus));
                    if (hExtra > 0)
                    {
                        tgt.DamageMobj(pp_source, e.Inflictor, hExtra, 'Heavy');
                        CVar cDbgHeavy = CVar.GetCVar("dr_dbg_hits");
                        if (cDbgHeavy && cDbgHeavy.GetInt() != 0)
                        {
                            pp_source.A_Log(String.Format("[DR DMG] Heavy +%d%% vs %s (MaxHP %d)", int(hbonus*100.0 + 0.5), tgt.GetClassName(), baseHP));
                        }
                    }
                }
            }
            }
        }

        // Monster scaled damage (timer difficulty) -> apply outgoing mult if tagged
        Actor monster_source = e.DamageSource;
        if (monster_source && monster_source.bIsMonster)
        {
            let stat_item = DR_StatHolder(monster_source.FindInventory("DR_StatHolder"));
            if (stat_item)
            {
                double d_scale = double(stat_item.Amount) / 1000.0;
                if (d_scale > 1.0)
                {
// WTD moved to ModifyDamage: e.Damage = int(double(e.Damage) * d_scale * DR_DIFFICULTY_DAMAGE_MULT);
                }
            }

        }

        // INCOMING: monster -> player (apply DR)
        PlayerPawn pp_victim = PlayerPawn(e.Thing);
        if (pp_victim)
        {
            RogueStats stv = GetOrGiveStats(pp_victim);
            if (stv)
            {
                double dr_total = RogueBoons.DR_Total(stv);
                if (dr_total > 0.0)
                {
                    int before = e.Damage;
// WTD moved to ModifyDamage: e.Damage = int(ceil(double(e.Damage) * (1.0 - dr_total)));
// WTD moved to ModifyDamage: if (e.Damage < 0) e.Damage = 0;

                    if (DebugOn() && DebugLevel() >= 2)
                    {
                        DLog(pp_victim, String.Format("[DR DMG IN] base:%d -> %d  (DR: %.1f%%)", before, e.Damage, dr_total*100.0));
                    }
                }
            }
        }
    }


    override void PlayerEntered(PlayerEvent e)
    {
        int pn = e.PlayerNumber; if (pn < 0 || pn >= MAXPLAYERS) return;
        PlayerInfo pi = players[pn]; if (!pi || !pi.mo) return;
        PlayerPawn pp = PlayerPawn(pi.mo);
        RogueStats st = GetOrGiveStats(pp);

        Name mn = level.MapName;
        // Detect a new game start and reset stats on the first map.  We only
        // perform this reset when the player has just entered MAP01/E1M1 at
        // the beginning of a run (level.time < 2).  Otherwise, the run timer
        // and XP persist across maps.
        if ((mn == 'MAP01' || mn == 'E1M1') && level.time < 2)
        {
            if (st)
            {
                st.Destroy();
                GetOrGiveStats(pp);
                pp.A_Log("[DR] New Game detected: stats reset.");
            }
        }
        // After acquiring a stats object, emit a debug summary of the player's state.
        // This includes the current run timer (MM:SS), the stage HP scale and XP multipliers.
        if (RogueCoreHandler.DebugOn() && RogueCoreHandler.DebugLevel() >= 2)
        {
            RogueStats st_dbg = GetOrGiveStats(pp);
            if (st_dbg != null)
            {
                int tsec = st_dbg.RunTimerSec;
                int tmin = tsec / 60;
                int tss  = tsec % 60;
                double stage = RogueCoreHandler.DR_GetHPScale();
                double gxp   = (st_dbg.GlobalXPMult > 0 ? st_dbg.GlobalXPMult : 1.0);
                double gdm   = (st_dbg.GlobalDmgMult > 0 ? st_dbg.GlobalDmgMult : 1.0);
                pp.A_Log(String.Format("[DR DBG] Run=%02d:%02d  Stage=%.2fx  GXP=%.2fx  GDM=%.2fx", tmin, tss, stage, gxp, gdm));
            }
        }
    }

    override void WorldThingSpawned(WorldEvent e)
    {
        
        
        Actor thing = e.Thing; if (!thing) return;

        
        // Stamp real MaxHP for accurate XP later
        // Stage-based HP scaling (single-apply per spawn)
        if (thing.bIsMonster)
        {
            double f = DR_GetHPScale();
            if (f > 1.001)
            {
                thing.GiveInventory("DR_MonHPScale", 1);
                DR_MonHPScale tag = DR_MonHPScale(thing.FindInventory("DR_MonHPScale"));
                if (tag != null)
                {
                    double factor = f / max(tag.applied, 1.0);
                    int nh = int(ceil(double(thing.health) * factor));
                    if (nh > thing.health) thing.health = nh;
                    tag.applied = f;
                }
            }
        }
        // Record spawn-time max HP (once)
        if (thing.bIsMonster && !thing.FindInventory("DR_HPStamp"))
        {
            thing.GiveInventory("DR_HPStamp", 1);
            DR_HPStamp hs = DR_HPStamp(thing.FindInventory("DR_HPStamp"));
            if (hs) hs.MaxHP = thing.Health;
        }
        // Scale newly spawned monsters by global difficulty (once)
        if (thing.bIsMonster && !thing.FindInventory("DR_TimerScaled"))
        {
            if (players[0].mo != null)
            {
                RogueStats st = GetOrGiveStats(players[0].mo);
                {
                    double sc = RogueCoreHandler.DR_GetHPScale();
                    if (sc > 1.0)
                    {
// === DR NOTE [0.5.259] â 2025-09-02 19:52:47 EDT â Section: Spawn Path â Monster HP scaling ===
// === DR CHECKLIST [0.5.260] â 2025-09-02 19:55:49 EDT â Spawn Path â HP Scaling ===
// [x] CODE: Uses DR_GetHPScale() Ã DR_DIFFICULTY_HEALTH_MULT
// [x] CODE: Seeds DR_MonHPScale.applied on spawn to prevent doubles
// [ ] USER: Fresh spawns mid-run feel appropriately tankier
// Confidence: 99.2000% | Completion: 98%
// Future attacks:
//  â¢ Ensure DR_MonHPScale.applied seeded here prevents double-scaling
//  â¢ If coop late-join: consider soft catch-up HP for fresh spawns only
// Bookmarks: [DR_NOTE_SpawnPathMonsterHPscaling]
                        thing.Health = int(double(thing.SpawnHealth()) * sc * DR_DIFFICULTY_HEALTH_MULT);
                        if (thing.bIsMonster)
                        {
                            thing.GiveInventory("DR_MonHPScale", 1);
                            DR_MonHPScale tag2 = DR_MonHPScale(thing.FindInventory("DR_MonHPScale"));
                            if (tag2) tag2.applied = sc;
                        }
                    }
                }
            }
            thing.GiveInventory("DR_TimerScaled", 1);
        }


        // Replace pickups with proxies
        if (IsOurPickupProxy(thing)) return;

        class<Actor> cls = thing.GetClass();
        Name replacement = "";
        if (cls == 'ArmorBonus')   replacement = 'DR_ArmorBonusProxy';
        if (cls == 'Stimpack')     replacement = 'DR_StimpackProxy';
        if (cls == 'Medikit')      replacement = 'DR_MedikitProxy';
        if (cls == 'HealthBonus')  replacement = 'DR_HealthBonusProxy';
        if (cls == 'SoulSphere')   replacement = 'DR_SoulSphereProxy';
        if (cls == 'Megasphere')   replacement = 'DR_MegasphereProxy';
        if (cls == 'GreenArmor')   replacement = 'DR_GreenArmorProxy';
        if (cls == 'BlueArmor')    replacement = 'DR_BlueArmorProxy';
        if (cls == 'Berserk')      replacement = 'DR_BerserkProxy';

        if (replacement != "")
        {
            Actor r = Actor.Spawn(replacement, thing.Pos, false);
            if (r) { r.Angle = thing.Angle; r.Vel = thing.Vel; }
            thing.Destroy();
            return;
        }
    }

    override void WorldThingDied(WorldEvent e)
    {
        
        if (!e || !e.Thing) return;
        Actor victim = e.Thing;
        if (victim && (victim is 'PlayerPawn')) return;

        PlayerPawn killer = PlayerPawn(victim ? victim.Target : null);
        if (!killer)
        {
            PlayerInfo cpi = players[consoleplayer];
            if (cpi && cpi.mo) killer = PlayerPawn(cpi.mo);
        }
        if (!killer) return;

        RogueStats st = GetOrGiveStats(killer);
if (st == null) return;

int widx = SnapWeaponIndex(killer);
if (widx < 0 || widx >= RW_Count)
{
    RogueStats st2 = RogueStats(killer.FindInventory("RogueStats"));
    if (st2 && (level.time - st2.LastWpnTick) <= 12) widx = st2.LastWpnIdx;
}
if (widx < 0 || widx >= RW_Count) return;

DR_HPStamp hs = DR_HPStamp(victim.FindInventory("DR_HPStamp"));
int xp = (victim.SpawnHealth() > 0 ? victim.SpawnHealth() : 50);
if (hs && hs.MaxHP > 0) xp = hs.MaxHP;
st.AddXP(widx, xp);

        // Debug kill log: show victim class, base HP, XP gained and current weapon level.  Emit only when
        // dr_dbg_hits is nonzero.  This helps tune XP and damage progression.
        CVar cHitsKill = CVar.GetCVar("dr_dbg_hits");
        if (cHitsKill && cHitsKill.GetInt() != 0)
        {
            String vcls = victim.GetClassName();
            int vbase = victim.SpawnHealth();
            int scaled = (hs && hs.MaxHP > 0) ? hs.MaxHP : vbase;
            int lvlNow = st.Level[widx];
            // Determine stage scale and approximate stage number for this kill.
            double scale = 1.0;
            if (vbase > 0)
            {
                scale = double(scaled) / double(vbase);
            }
            else
            {
                scale = DR_GetHPScale();
            }
            int stageNum = 0;
            if (scale > 1.0)
            {
                // Approximate the stage number for kill logs using the
                // beta 13 increment of 0.07× per stage beyond Stage 0.  This
                // provides an intuitive stage index when reading logs.
                stageNum = 1 + int(((scale - 1.0) / 0.07) + 0.5);
                if (stageNum < 1) stageNum = 1;
            }
            PlayerPawn pp_tmp = killer;
            pp_tmp.A_Log(String.Format("[DR KILL] %s (HP %d/%d) via %s Lvl %d | Stage %d Scale %.2fx | XP +%d", vcls, victim.health, scaled, RogueUtil.IndexToName(widx), lvlNow, stageNum, scale, xp));
        }

        // Soul Siphon timed buff: heals on every kill during the active window.
        // Each pickup increases SoulSiphonLevel (1–5 HP per kill) and resets the timer.
        // A short internal cooldown prevents multiple heals from rapid multi‑projectile
        // kills.  Overheal to 200 HP is allowed.  Always print a concise log so
        // testers can verify the effect.
        if (st.Boon_SoulSiphon && st.SoulSiphonTics > 0 && st.SoulSiphonLevel > 0)
        {
            // Heal only when the internal cooldown has expired to avoid multiple
            // heals from the same kill.  Reset the cooldown (0.25 s) after
            // applying the heal.
            if (st.SoulSiphonCDTics <= 0)
            {
                // Capture the player’s HP before applying the heal so we can report
                // before→after values in the log.  Then heal and reset the cooldown.
                int beforeHP = killer.health;
                int healAmt  = st.SoulSiphonLevel;
                RogueBoons.HealCapped(killer, healAmt, true);
                st.SoulSiphonCDTics = int(0.25 * TICRATE + 0.5);
                int afterHP  = killer.health;
                // Compute dynamic max HP based on Raise Max Health tiers.
                // Compute the dynamic HP cap for logging: start from DR_MAX_HEALTH_CAP and
                // add both major and minor Raise Max Health bonuses.  Clamp to
                // DR_RAISE_HEALTH_CAP.  This mirrors HealCapped() logic.
                int capHP    = DR_MAX_HEALTH_CAP
                    + st.MaxHealthBonus * DR_RAISE_HEALTH_INC
                    + st.MinorHealthBonus * DR_RAISE_HEALTH_MINI_INC;
                if (capHP > DR_RAISE_HEALTH_CAP) capHP = DR_RAISE_HEALTH_CAP;
                int remSec   = int(ceil(double(st.SoulSiphonTics) / TICRATE));
                killer.A_Log(String.Format("[DR SS] +%d HP (HP %d→%d/%d, Tier %d, %d s left)", healAmt, beforeHP, afterHP, capHP, st.SoulSiphonLevel, remSec));
            }
            else
            {
                // Cooldown active: skip healing but still provide a debug note at
                // high verbosity to illustrate why no heal occurred.  This
                // prevents confusion when multiple projectiles hit the same
                // monster.
                if (RogueCoreHandler.DebugOn() && RogueCoreHandler.DebugLevel() >= 2)
                {
                    killer.A_Log(String.Format("[DR SS DBG] cooldown %d tics – no heal", st.SoulSiphonCDTics));
                }
            }
        }

        // Crowd Frenzy: chain kill buff.  If the Frenzy boon is owned, each kill
        // contributes to a stack when performed within the kill window.  Stacks
        // reset if the window has expired.  Each stack increases outgoing
        // damage by DR_FRENZY_PER_STACK for DR_FRENZY_BUFF_DURATION seconds.  Log
        // the current stack count and remaining buff duration.
        if (st.FrenzyOwned)
        {
            // Determine if this kill is within the chain window
            if (st.FrenzyKillWindowTics > 0)
            {
                if (st.FrenzyStacks < DR_FRENZY_MAX_STACKS) st.FrenzyStacks++;
            }
            else
            {
                st.FrenzyStacks = 1;
            }
            st.FrenzyKillWindowTics = int(DR_FRENZY_KILL_WINDOW * TICRATE + 0.5);
            st.FrenzyBuffTics = int(DR_FRENZY_BUFF_DURATION * TICRATE + 0.5);
            // Log Frenzy stack; always visible for easy tuning
            int rem_s = int(ceil(double(st.FrenzyBuffTics) / TICRATE));
            killer.A_Log(String.Format("[DR DMG] Frenzy x%d (+%d%%, %d s)", st.FrenzyStacks, st.FrenzyStacks * int(DR_FRENZY_PER_STACK * 100.0 + 0.5), rem_s));
        }

        // Bulwark Shards: grant shards on kill according to tier.  Each tier
        // grants an additional shard.  Cap at BulwarkShardMax.  Log the gain
        // and the current shard count.
        if (st.BulwarkShardLevel > 0)
        {
            int addSh = st.BulwarkShardLevel;
            st.BulwarkShardCount += addSh;
            if (st.BulwarkShardCount > st.BulwarkShardMax) st.BulwarkShardCount = st.BulwarkShardMax;
            killer.A_Log(String.Format("[DR BULWARK] +%d Shard%s (%d/%d)", addSh, (addSh > 1 ? "s" : ""), st.BulwarkShardCount, st.BulwarkShardMax));
        }

}


    // Static helper moved inside class to satisfy top-level decl rules
// === DR NOTE [0.5.259] â 2025-09-02 19:52:47 EDT â Section: Timer Stages â DR_GetHPScale() 5-stage ===
// Update [0.5.262] â 2025-09-02 20:23:52 EDT: Extended beyond 5 stages via linear +0.15 step extrapolation; stage timing unchanged.
// Confidence: 99.3000% | Completion: 97%
// Future attacks:
//  â¢ Expose dr_hp_scale_minutes for field tuning (kept at 3.0 default)
//  â¢ Add survival HUD line that shows stage/timer (behind debug CVAR)
// Bookmarks: [DR_NOTE_TimerStagesDRGetHPScale5stage]
    static double DR_GetHPScale()
    {
        // Difficulty-aware staged scaling: 0..∞ stages => 1.00..1.75× and beyond
        // Stage interval = base minutes * skill factor.  To keep the difficulty
        // continuous across maps, use the player's run timer (RogueStats.RunTimerSec)
        // rather than the per‑map clock.  If no players are present, fall back
        // to the map time so single‑frame calculations still work.
        CVar c_en = CVar.GetCVar("dr_hp_scale_enable");
        if (c_en == null || c_en.GetBool())
        {
            // Base duration in minutes between stage increases (default 3).
            // Stage length is determined by a base value (DR_STAGE_BASE_MIN) and a per-skill
            // multiplier.  CVAR dr_hp_scale_minutes overrides the base value if defined.
            double baseMin = DR_STAGE_BASE_MIN;
            CVar c_min = CVar.GetCVar("dr_hp_scale_minutes");
            if (c_min != null)
            {
                double b = c_min.GetFloat();
                if (b >= 0.25) baseMin = b;
            }
            // Determine skill multiplier: see DR_STAGE_SKILL_MUL for ordering 0..4.
            int sk = 2;
            CVar cvskill = CVar.GetCVar("skill");
            if (cvskill != null) sk = clamp(cvskill.GetInt(), 0, 4);
            // Determine skill multiplier via helper.  Avoids top-level constant arrays.
            double minutes = baseMin * DRPatchHelpers.StageSkillMultiplier(sk);
            // Apply Stage Tamer effect: lengthen the stage duration by 10% or 15%
            // depending on the player's Stage Tamer tier.  We use the first
            // available player’s stats for simplicity.  If multiple players have
            // Stage Tamer, the highest tier wins.
            int tamerTier = 0;
            for (int i = 0; i < MAXPLAYERS; i++)
            {
                if (players[i].mo != null)
                {
                    RogueStats st_t = GetOrGiveStats(PlayerPawn(players[i].mo));
                    if (st_t != null && st_t.StageTamerLevel > tamerTier)
                    {
                        tamerTier = st_t.StageTamerLevel;
                    }
                }
            }
            if (tamerTier > 0)
            {
                if (tamerTier == 1) minutes *= (1.0 + DR_STAMER_SLOW1);
                else minutes *= (1.0 + DR_STAMER_SLOW2);
            }

            // Fetch global run timer in seconds from the first available player.  This
            // ensures the timer continues across maps.  If no stats are found, use
            // the map time as a fallback so the function remains defined.
            int runSec = 0;
            for (int i = 0; i < MAXPLAYERS; i++)
            {
                if (players[i].mo != null)
                {
                    RogueStats st = GetOrGiveStats(PlayerPawn(players[i].mo));
                    if (st != null)
                    {
                        runSec = st.RunTimerSec;
                        break;
                    }
                }
            }
            double elapsedMin = 0.0;
            if (runSec > 0)
            {
                // Convert run timer from tics to minutes.  Each tic is 1/35 second (TICRATE).
                elapsedMin = double(runSec) / (TICRATE * 60.0);
            }
            else
            {
                // fallback to map time if run timer is not yet initialised
                double tics = double(level.maptime);
                // level.maptime is also in tics.
                elapsedMin = tics / (TICRATE * 60.0);
            }

            double stage_d = 0.0;
            if (minutes > 0.01)
            {
                stage_d = elapsedMin / minutes;
            }
            // Determine integer stage index (floor), but allow values beyond table for scaling
            int stage = 0;
            if (stage_d > 0.0)
            {
                stage = int(floor(stage_d));
                if (stage < 0) stage = 0;
            }
            // Base table for first 6 stages; beyond that continue linear increments of +0.15
            // Stage scaling table for the first six stages.  Subsequent stages
            // continue increasing linearly with a small step (0.07).  The
            // values here were chosen for beta 13 to soften the scaling and
            // prevent monsters from becoming too durable early in a run.
            // Stage 0 = 1.00, Stage 1 = 1.05, Stage 2 = 1.10, Stage 3 = 1.16,
            // Stage 4 = 1.23, Stage 5 = 1.31.  Beyond Stage 5, each stage
            // increases the scale by +0.07.
            double table[6] = { 1.00, 1.05, 1.10, 1.16, 1.23, 1.31 };
            double target;
            if (stage < 6)
            {
                target = table[stage];
            }
            else
            {
                // Extrapolate beyond last entry: each stage adds 0.07× to the
                // scale.  This gentle slope slows down difficulty growth on
                // extended runs.
                target = table[5] + (double(stage - 5)) * 0.07;
            }
            // Respect cap override if provided
            CVar c_cap = CVar.GetCVar("dr_hp_scale_cap");
            if (c_cap != null)
            {
                double capVal = c_cap.GetFloat();
                if (capVal >= 1.0 && target > capVal) target = capVal;
            }
            return target;
        }
        return 1.0;
    }
} // end class RogueCoreHandler


// -- Global version constants (moved out of class to avoid parser edge cases) --
// -- Global helper for time/difficulty HP scaling --

// ---- PATCH: add class RogueHUDSnap ----
class RogueHUDSnapInv : Inventory
{
    // snapshot fields read by HUD (ui-safe)
    int WIdx;
    int CurLvl, CurXP, NeedXP;

    // toast fields (level up and boon)
    int ToastTics;
    int ToastKind; // 1=levelup, 2=boon
    String ToastMsg;
    String ToastMsg2;

    override void BeginPlay()
    {
        bKeepDepleted = true;
        MaxAmount = 1;
Amount = 1;
            Super.BeginPlay();
    }
}


// ---- PATCH: add class RoguePlayEH ----
class RoguePlayEH : EventHandler
{
}

// Stub StaticEventHandler to satisfy MAPINFO AddEventHandlers; inventory snapshot is RogueHUDSnapInv
class RogueHUDSnap : StaticEventHandler
{
    // Intentionally empty. Snapshot is managed by RogueHUDSnapInv and other systems.
}


// GZDoom 4.14.2 no longer defines StatusBarEventHandler. Instead, derive
// from StaticEventHandler to implement overlay drawing. StaticEventHandler
// exposes RenderOverlay(RenderEvent e) for UI scope. (Ref: ZDoom Wiki â
// Events and handlers)
class RogueHUD : StaticEventHandler
{
    Font toastF;
            HUDFont toastHF;

override void RenderOverlay(RenderEvent e)
    {
        int vW = Screen.GetWidth();
        int vH = Screen.GetHeight();

        // Big readable HUD, pushed down so console messages don't overlap
        int Y_PUSH = 88;
// pixels to push down below console messages
        int LEFTPAD = 10;
int MARGIN = 8;
PlayerInfo pi = players[consoleplayer];
        if (pi == null || pi.mo == null) return;
        PlayerPawn pp = PlayerPawn(pi.mo);
        if (pp == null) return;

        RogueStats st = RogueStats(pp.FindInventory('RogueStats'));
        if (st == null) return;

        Font titleFont = BigFont;
        Font rowFont   = BigFont;
        int  lineH     = rowFont.GetHeight() + 1;

        int bx = LEFTPAD;
        int by = Y_PUSH + MARGIN;

        // Title
        Screen.DrawText(titleFont, Font.CR_GOLD, bx, by, "DOOM ROGUE");
        by += titleFont.GetHeight() + 2;

        // Timer
        int secs = st.RunTimerSec;
        int mm = secs / 60; int ss = secs % 60;
        // Damage Reduction
        double dr = RogueBoons.DR_Total_UI(st);
        int drpct = int(dr * 100.0 + 0.5);
        Screen.DrawText(rowFont, Font.CR_GREEN, bx, by, String.Format("REDUCE  %d%%", drpct));
        by += lineH;

        // Bulwark (shard) display: show current shard count and cap instead of a DR percentage.  This
        // makes it clear how many defensive tokens the player has.  See DR_BulwarkShards logic in
        // ApplyBoon() and WorldThingDied() for shard generation and consumption.
        if (st.BulwarkShardLevel > 0)
        {
            Screen.DrawText(rowFont, Font.CR_LIGHTBLUE, bx, by,
                String.Format("BULWARK  %d/%d", st.BulwarkShardCount, st.BulwarkShardMax));
        }
        else
        {
            Screen.DrawText(rowFont, Font.CR_LIGHTBLUE, bx, by, "BULWARK  0/0");
        }
        by += lineH;
        // Weapon + level/xp: use the player's current weapon index for display; snapshot is still retrieved for toast messages
        RogueHUDSnapInv snap = RogueHUDSnapInv(pp.FindInventory('RogueHUDSnapInv'));
        int widx = (st.CurrentWeaponIndex >= 0 && st.CurrentWeaponIndex < RW_Count) ? st.CurrentWeaponIndex : RW_Fist;
        String wname = RogueUtil.IndexToName(widx);
        Screen.DrawText(rowFont, Font.CR_LIGHTBLUE, bx, by, String.Format("WEAPON  %s", wname));
        by += lineH;

        int lvl  = st.Level[widx];
        int cur  = st.XP[widx];
        int need = RogueXP.RequiredForNext(lvl, widx);
        if (need < 1) need = 1; if (cur < 0) cur = 0; if (cur > need) cur = need;
        int pct  = (cur * 100) / need;

        Screen.DrawText(rowFont, Font.CR_YELLOW, bx, by, String.Format("LEVEL   %d  (%d/%d)", lvl, cur, need));
        by += lineH;

                // XP bar (per-segment text to avoid string ops)
        int segs = 24;
        int filled = (segs * cur) / need;
        int sx = bx; int sy = by;
        Screen.DrawText(rowFont, Font.CR_TAN, sx, sy, "[");
        sx += rowFont.StringWidth("[");
        for (int s = 0; s < segs; s++)
        {
            bool on = s < filled;
            Screen.DrawText(rowFont, on ? Font.CR_GOLD : Font.CR_DARKGRAY, sx, sy, on ? "#" : ".");
            sx += rowFont.StringWidth("#");
        }
        Screen.DrawText(rowFont, Font.CR_TAN, sx, sy, "]");
        by += lineH;

        // Damage +%
        
        // === DR NOTE [0.5.263] â 2025-09-02 20:35:26 EDT â HUD Stage+Timer line ===
// Update [0.5.265] â 2025-09-02 23:22:05 EDT: Migrated to StatusBarEventHandler + DrawString(DI_SCREEN_LEFT_TOP); removed TIME-only duplicate.
// Update [0.5.264] â 2025-09-02 20:38:57 EDT: UI-scope safe â avoid world calls; fallback to 1.00 when stats missing.
        // Confidence: 99.2000% | Completion: 95%
        // Future attacks:
        //  â¢ Add CVAR dr_hud_stage to toggle display (default on)
        //  â¢ Colorize when a new stage is reached this tick
        // Bookmarks: [DR_NOTE_HUDStageTimer]
        // === DR CHECKLIST [0.5.263] â 2025-09-02 20:35:26 EDT â HUD Stage+Timer ===
        // [x] CODE: Shows RunTimerSec as MM:SS and DifficultyScale as x.xxÃ
        // [ ] USER: Verify placement/readability with your HUD scale
        // -----------------------------------------------
        // Convert the run timer from tics (1/35th of a second) to minutes and seconds.
        int ticks = (st ? st.RunTimerSec : 0);
        int totalSecs = ticks / TICRATE;
        int tmin = totalSecs / 60;
        int tss  = totalSecs % 60;
        double sc = (st && st.DifficultyScale > 0) ? st.DifficultyScale : 1.00; // UI-safe fallback
        String tline = String.Format("TIME  %02d:%02d   STAGE  %.2fx", tmin, tss, sc);
        Screen.DrawText(rowFont, Font.CR_GREEN, bx, by, tline);
        by += lineH;
        // Draw a progress bar for the upcoming stage.  The bar fills over the stage interval (default 3 minutes × skill factor).
        {
            double baseMin = DR_STAGE_BASE_MIN;
            CVar c_min = CVar.GetCVar("dr_hp_scale_minutes");
            if (c_min != null)
            {
                double b = c_min.GetFloat();
                if (b >= 0.25) baseMin = b;
            }
            int sk = 2;
            CVar cvskill = CVar.GetCVar("skill");
            if (cvskill != null)
            {
                sk = clamp(cvskill.GetInt(), 0, 4);
            }
            double minutes = baseMin * DRPatchHelpers.StageSkillMultiplier(sk);
            // Convert run timer tics to minutes for the progress bar.  Each stage length
            // is measured in real minutes (seconds / 60), so divide by TICRATE as well.
            double elapsedMin = double(st.RunTimerSec) / (TICRATE * 60.0);
            double prog = 0.0;
            if (minutes > 0.01)
            {
                int fullStages = int(elapsedMin / minutes);
                double rem = elapsedMin - double(fullStages) * minutes;
                prog = rem / minutes;
                if (prog < 0.0) prog = 0.0;
                if (prog > 1.0) prog = 1.0;
            }
            int segs = 24;
            int filled = int(double(segs) * prog + 0.5);
            int sx = bx;
            int sy = by;
            Screen.DrawText(rowFont, Font.CR_TAN, sx, sy, "[");
            sx += rowFont.StringWidth("[");
            for (int s = 0; s < segs; s++)
            {
                bool on = (s < filled);
                Screen.DrawText(rowFont, on ? Font.CR_GREEN : Font.CR_DARKGRAY, sx, sy, on ? "#" : ".");
                sx += rowFont.StringWidth("#");
            }
            Screen.DrawText(rowFont, Font.CR_TAN, sx, sy, "]");
            by += lineH;
        }
double mult = RogueDamage.MultForLevel(lvl) * (st.GlobalDmgMult > 0 ? st.GlobalDmgMult : 1.0);
        int dmgpct = int(mult * 100.0 + 0.5) - 100;
        Screen.DrawText(rowFont, Font.CR_GREEN, bx, by, String.Format("DMG     +%d%%", dmgpct));
        by += lineH;
        // XP bonus for current weapon
        {
            double gxp = (st.GlobalXPMult > 0) ? st.GlobalXPMult : 1.0;
            double txp = (st.TimedXPTics > 0 && st.TimedXPMult > 0) ? st.TimedXPMult : 1.0;
int xppct = int(gxp * txp * 100.0 + 0.5) - 100;
            Screen.DrawText(rowFont, Font.CR_LIGHTBLUE, bx, by, String.Format("XP      +%d%%", xppct));
            by += lineH;
        }

        // -----------------------------------------------------------------
        // Timed buff overlay
        //
        // Draw a small list of active timed buffs in the bottom‑left corner above
        // the status bar.  Because DI_SCREEN_* flags are unavailable in 4.14.2,
        // we anchor the overlay manually using Screen.GetHeight().  First count
        // how many buffs are active, then calculate a starting Y coordinate so
        // the list appears a fixed distance above the bottom of the screen.
        {
            // Use BigFont for the timed buff list so values are easier to read.  BigFont
            // scales with the HUD and remains legible on higher resolutions.  Increase
            // the line spacing slightly to separate entries.
            Font buffF = BigFont;
            int lineH2 = buffF.GetHeight() + 2;
            // Count active buffs
            int n = 0;
            if (st && st.SoulSiphonTics > 0 && st.SoulSiphonLevel > 0) n++;
            if (st && st.TimedXPTics > 0 && st.TimedXPMult > 1.0) n++;
            if (st && st.FrenzyBuffTics > 0 && st.FrenzyStacks > 0) n++;
            if (st && st.QuadTics > 0) n++;
            if (st && st.BloodRiteTics > 0) n++;
            if (st && st.AdrenalShieldTics > 0) n++;
            if (n > 0)
            {
                int overlayH = n * lineH2;
                // Draw the overlay higher above the bottom to avoid overlapping the
                // status bar.  In beta 27 the margin has been increased further
                // (from 90 pixels to 120 pixels) so the buff list sits clearly
                // above the player HUD across all resolutions.  The height of
                // the list is subtracted so entries stack upward.
                int startY = vH - 120 - overlayH;
                int startX = 10;
                int idx = 0;
                // Soul Siphon: show HP per kill and seconds remaining
                if (st && st.SoulSiphonTics > 0 && st.SoulSiphonLevel > 0)
                {
                    int ssSec = int(ceil(double(st.SoulSiphonTics) / TICRATE));
                    // Remove the trailing 's' from the seconds display per playtester feedback
                    // Format Soul Siphon timer with a hyphen instead of a colon per playtester feedback.  Remove the trailing 's' on seconds.
                    String ssMsg = String.Format("Soul Siphon - +%d HP/kill  %d", st.SoulSiphonLevel, ssSec);
                    Screen.DrawText(buffF, Font.CR_GREEN, startX, startY + lineH2 * idx, ssMsg);
                    idx++;
                }
                // XP Surge timed buff
                if (st && st.TimedXPTics > 0 && st.TimedXPMult > 1.0)
                {
                    int xpSec = int(ceil(double(st.TimedXPTics) / TICRATE));
                    int xpPct = int((st.TimedXPMult - 1.0) * 100.0 + 0.5);
                    // Remove the trailing 's' from the seconds display per playtester feedback
                    // Format XP Surge timer with a hyphen instead of a colon.  Seconds appear without the trailing 's'.
                    String xpMsg = String.Format("XP Surge - +%d%% XP  %d", xpPct, xpSec);
                    Screen.DrawText(buffF, Font.CR_LIGHTBLUE, startX, startY + lineH2 * idx, xpMsg);
                    idx++;
                }
                // Frenzy damage buff
                if (st && st.FrenzyBuffTics > 0 && st.FrenzyStacks > 0)
                {
                    int frSec = int(ceil(double(st.FrenzyBuffTics) / TICRATE));
                    int frPct = int(DR_FRENZY_PER_STACK * double(st.FrenzyStacks) * 100.0 + 0.5);
                    // Remove the trailing 's' from the seconds display per playtester feedback
                    // Format Frenzy timer with a hyphen and include stacks and seconds sans the trailing 's'.
                    String frMsg = String.Format("Frenzy - +%d%% dmg (%d)  %d", frPct, st.FrenzyStacks, frSec);
                    Screen.DrawText(buffF, Font.CR_RED, startX, startY + lineH2 * idx, frMsg);
                    idx++;
                }
                // Quad Damage buff
                if (st && st.QuadTics > 0)
                {
                    int qSec = int(ceil(double(st.QuadTics) / TICRATE));
                    // Remove the trailing 's' from the seconds display per playtester feedback
                    // Format Quad Damage timer with a hyphen; show seconds without the trailing 's'.
                    String qMsg = String.Format("Quad Damage - %d", qSec);
                    Screen.DrawText(buffF, Font.CR_ORANGE, startX, startY + lineH2 * idx, qMsg);
                    idx++;
                }
                // Berserk Rite / Blood Rite buff
                if (st && st.BloodRiteTics > 0)
                {
                    int brSec = int(ceil(double(st.BloodRiteTics) / TICRATE));
                    int lifepct = int(DR_BR_LIFESTEAL * 100.0 + 0.5);
                    // Remove the trailing 's' from the seconds display per playtester feedback
                    // Format Berserk Rite timer with a hyphen and include lifesteal percentage and seconds sans 's'.
                    String brMsg = String.Format("Berserk Rite - %d%% lifesteal  %d", lifepct, brSec);
                    Screen.DrawText(buffF, Font.CR_PURPLE, startX, startY + lineH2 * idx, brMsg);
                    idx++;
                }
                // Adrenal Surge buff
                if (st && st.AdrenalShieldTics > 0)
                {
                    int asSec = int(ceil(double(st.AdrenalShieldTics) / TICRATE));
                    // Remove the trailing 's' from the seconds display per playtester feedback
                    // Format Adrenal Surge timer with a hyphen and show remaining seconds without 's'.
                    String asMsg = String.Format("Adrenal Surge - Shield  %d", asSec);
                    Screen.DrawText(buffF, Font.CR_GREEN, startX, startY + lineH2 * idx, asMsg);
                    idx++;
                }
            }
        }


        // Toasts (10s) â bottom-center above status bar
        
        if (snap && snap.ToastTics > 0 && snap.ToastMsg && snap.ToastMsg.Length() > 0)
        {
            Font f = (toastF == null) ? BigFont : toastF;
            // HUDFont init not needed for Screen.DrawText
            // HUD CVARs for left panel positioning
            int hudX = 0; CVar chx = CVar.GetCVar("dr_hud_x"); if (chx) hudX = chx.GetInt();
            int hudY = 0; CVar chy = CVar.GetCVar("dr_hud_y"); if (chy) hudY = chy.GetInt();
            HUDFont __hudF = HUDFont.Create(SmallFont);

            double sscale = 1.0; // using BigFont without additional scale
            CVar cvs = CVar.GetCVar("dr_toast_scale");
            if (cvs) { double t = cvs.GetFloat(); if (t >= 0.50 && t <= 6.0) sscale = t; }

            // 320x200 HUD-virtual center math (no DI_* flags dependency)
            int hudW = 320;
            int hudH = 200;
            int linesN = (snap.ToastMsg2 && snap.ToastMsg2.Length() > 0) ? 2 : 1;
            int fh = f.GetHeight();
            int baseY = 30; // near top center like "A SECRET IS REVEALED!"

            CVar cvyo = CVar.GetCVar("dr_toast_yofs"); if (cvyo) baseY += cvyo.GetInt();
            // First line
            String s1 = snap.ToastMsg;
            int w1 = f.StringWidth(s1);
            int x1 = (hudW - int(w1 * sscale)) / 2;
            int y1 = baseY;
                Screen.DrawText(f, Font.CR_GOLD, x1, y1, s1);

            // Optional second line
            if (linesN == 2)
            {
                String s2 = snap.ToastMsg2;
                int w2 = f.StringWidth(s2);
                int x2 = (hudW - int(w2 * sscale)) / 2;
                int y2 = y1 + int(fh * sscale) + 4;
                    Screen.DrawText(f, Font.CR_LIGHTBLUE, x2, y2, s2);
            }
        }
int y = by + 8;
        int curIdx = st.CurrentWeaponIndex;

        for (int i = 0; i < RW_Count; i++)
        {
            String wname = RogueUtil.IndexToName_UI(i);
            int level = st.Level[i];
            int need = RogueXP.RequiredForNext(level, i);
            int curXP = st.XP[i];
            int pct = (need > 0) ? (curXP * 100) / need : 0;

                int colorL = (i == curIdx) ? Font.CR_GOLD : Font.CR_WHITE;
                int colorR = (i == curIdx) ? Font.CR_GOLD : Font.CR_LIGHTBLUE;

            Screen.DrawText(rowFont, colorL, bx, y, wname);
            int nameW = rowFont.StringWidth(wname);

            String r = String.Format("LV %d (%d%%)", level, pct);
            int infoX = bx + nameW + 12;
            Screen.DrawText(rowFont, colorR, infoX, y, r);

            y += lineH;
        }
    }}  
 
// === DR CHECKLIST [0.5.260] â 2025-09-02 19:55:49 EDT â MASTER LAUNCH CHECK ===
// [x] CODE: HUD uses StaticEventHandler.RenderOverlay + Screen.DrawText (policy compliant)
// [ ] USER-CONFIRM: HUD shows correct weapon name at map start (Pistol, not Fist)
// [ ] USER-CONFIRM: XP pacing feels sane on HMP; Zombieman ~3â5% bar; Cyber capped at 200 XP
// [ ] USER-CONFIRM: Console shows exact boon names with short numeric details
// [ ] USER-CONFIRM: Defense pity triggers within 3 rolls if none appear
// [ ] USER-CONFIRM: Timer stages: HP scales at 0/3/6/9/12/15 (HMP) using [1.00,1.15,1.30,1.45,1.60,1.75]
// [ ] USER-CONFIRM: No double-scaling when stage advances mid-fight
// [ ] USER-CONFIRM: âCore 8â feels clean (no redundant/odd boons)
// [x] CODE-CONFIRM: XP math uses GlobalXPMult Ã TimedXPMult only (universal boons)
// [x] CODE-CONFIRM: DR_MonHPScale.applied seeded at spawn; sweeps apply delta only
// [x] CODE-CONFIRM: OverMult[w] clamps to DR_OVERMULT_CAP=1.50 after multipliers

// --------------------------------------------------------------------------
// Smoke-Test Harness
//
// A minimal DR_TestHarness implementation to satisfy MAPINFO AddEventHandlers.
// This handler is gated by the CVAR 'dr_testharness' (default 0). When enabled,
// it can be extended to spawn dummy actors and log damage/XP/boon events for
// automated regression testing. At present it simply prints a message to the
// console on world load if the CVAR is non-zero. Modify WorldLoaded() to add
// further diagnostics.
//
// Ref: ZDoom Wiki â EventHandler and WorldLoaded() docsã950367212508399â L11-L32ã.
class DR_TestHarness : EventHandler
{
    // Checks cvar at level load and prints a message; extend as needed.
    override void WorldLoaded(WorldEvent e)
    {
        CVar c = CVar.GetCVar("dr_testharness");
        if (c && c.GetInt() != 0)
        {
            Console.Printf("DR_TestHarness enabled (CVAR dr_testharness != 0)");
            // Additional test logic can be added here, e.g. spawning targets.
        }
    }
}
